"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/earcut";
exports.ids = ["vendor-chunks/earcut"];
exports.modules = {

/***/ "(ssr)/./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ earcut),\n/* harmony export */   deviation: () => (/* binding */ deviation),\n/* harmony export */   flatten: () => (/* binding */ flatten)\n/* harmony export */ });\nfunction earcut(data, holeIndices, dim = 2) {\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    let outerNode = linkedList(data, 0, outerLen, dim, true);\n    const triangles = [];\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n    let minX, minY, invSize;\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = Infinity;\n        minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n        for(let i = dim; i < outerLen; i += dim){\n            const x = data[i];\n            const y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n    return triangles;\n}\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    let last;\n    if (clockwise === signedArea(data, start, end, dim) > 0) {\n        for(let i = start; i < end; i += dim)last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n    } else {\n        for(let i = end - dim; i >= start; i -= dim)last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n    }\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n    return last;\n}\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n    let p = start, again;\n    do {\n        again = false;\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n        } else {\n            p = p.next;\n        }\n    }while (again || p !== end);\n    return end;\n}\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n    let stop = ear;\n    // iterate through ears, slicing them one by one\n    while(ear.prev !== ear.next){\n        const prev = ear.prev;\n        const next = ear.next;\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            triangles.push(prev.i, ear.i, next.i); // cut off the triangle\n            removeNode(ear);\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n            continue;\n        }\n        ear = next;\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n            break;\n        }\n    }\n}\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    const a = ear.prev, b = ear, c = ear.next;\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n    // now make sure we don't have other points inside the potential ear\n    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n    // triangle bbox\n    const x0 = Math.min(ax, bx, cx), y0 = Math.min(ay, by, cy), x1 = Math.max(ax, bx, cx), y1 = Math.max(ay, by, cy);\n    let p = c.next;\n    while(p !== a){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n    return true;\n}\nfunction isEarHashed(ear, minX, minY, invSize) {\n    const a = ear.prev, b = ear, c = ear.next;\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n    // triangle bbox\n    const x0 = Math.min(ax, bx, cx), y0 = Math.min(ay, by, cy), x1 = Math.max(ax, bx, cx), y1 = Math.max(ay, by, cy);\n    // z-order range for the current triangle bbox;\n    const minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);\n    let p = ear.prevZ, n = ear.nextZ;\n    // look for points inside the triangle in both directions\n    while(p && p.z >= minZ && n && n.z <= maxZ){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n    // look for remaining points in decreasing z-order\n    while(p && p.z >= minZ){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n    // look for remaining points in increasing z-order\n    while(n && n.z <= maxZ){\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n    return true;\n}\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles) {\n    let p = start;\n    do {\n        const a = p.prev, b = p.next.next;\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n            triangles.push(a.i, p.i, b.i);\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n            p = start = b;\n        }\n        p = p.next;\n    }while (p !== start);\n    return filterPoints(p);\n}\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    let a = start;\n    do {\n        let b = a.next.next;\n        while(b !== a.prev){\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                let c = splitPolygon(a, b);\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    }while (a !== start);\n}\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    const queue = [];\n    for(let i = 0, len = holeIndices.length; i < len; i++){\n        const start = holeIndices[i] * dim;\n        const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        const list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n    queue.sort(compareXYSlope);\n    // process holes from left to right\n    for(let i = 0; i < queue.length; i++){\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n    return outerNode;\n}\nfunction compareXYSlope(a, b) {\n    let result = a.x - b.x;\n    // when the left-most point of 2 holes meet at a vertex, sort the holes counterclockwise so that when we find\n    // the bridge to the outer shell is always the point that they meet at.\n    if (result === 0) {\n        result = a.y - b.y;\n        if (result === 0) {\n            const aSlope = (a.next.y - a.y) / (a.next.x - a.x);\n            const bSlope = (b.next.y - b.y) / (b.next.x - b.x);\n            result = aSlope - bSlope;\n        }\n    }\n    return result;\n}\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    const bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n    const bridgeReverse = splitPolygon(bridge, hole);\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    let p = outerNode;\n    const hx = hole.x;\n    const hy = hole.y;\n    let qx = -Infinity;\n    let m;\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    // unless they intersect at a vertex, then choose the vertex\n    if (equals(hole, p)) return p;\n    do {\n        if (equals(hole, p.next)) return p.next;\n        else if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    }while (p !== outerNode);\n    if (!m) return null;\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n    const stop = m;\n    const mx = m.x;\n    const my = m.y;\n    let tanMin = Infinity;\n    p = m;\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n            const tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n        p = p.next;\n    }while (p !== stop);\n    return m;\n}\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    let p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    }while (p !== start);\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n    sortLinked(p);\n}\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    let numMerges;\n    let inSize = 1;\n    do {\n        let p = list;\n        let e;\n        list = null;\n        let tail = null;\n        numMerges = 0;\n        while(p){\n            numMerges++;\n            let q = p;\n            let pSize = 0;\n            for(let i = 0; i < inSize; i++){\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            let qSize = inSize;\n            while(pSize > 0 || qSize > 0 && q){\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n                if (tail) tail.nextZ = e;\n                else list = e;\n                e.prevZ = tail;\n                tail = e;\n            }\n            p = q;\n        }\n        tail.nextZ = null;\n        inSize *= 2;\n    }while (numMerges > 1);\n    return list;\n}\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n    x = (x | x << 8) & 0x00FF00FF;\n    x = (x | x << 4) & 0x0F0F0F0F;\n    x = (x | x << 2) & 0x33333333;\n    x = (x | x << 1) & 0x55555555;\n    y = (y | y << 8) & 0x00FF00FF;\n    y = (y | y << 4) & 0x0F0F0F0F;\n    y = (y | y << 2) & 0x33333333;\n    y = (y | y << 1) & 0x55555555;\n    return x | y << 1;\n}\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    let p = start, leftmost = start;\n    do {\n        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n        p = p.next;\n    }while (p !== start);\n    return leftmost;\n}\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n// check if a point lies within a convex triangle but false if its equal to the first point of the triangle\nfunction pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {\n    return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);\n}\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n    (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n    (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n    equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    const o1 = sign(area(p1, q1, p2));\n    const o2 = sign(area(p1, q1, q2));\n    const o3 = sign(area(p2, q2, p1));\n    const o4 = sign(area(p2, q2, q1));\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n    return false;\n}\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    let p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    }while (p !== a);\n    return false;\n}\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    let p = a;\n    let inside = false;\n    const px = (a.x + b.x) / 2;\n    const py = (a.y + b.y) / 2;\n    do {\n        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n        p = p.next;\n    }while (p !== a);\n    return inside;\n}\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    const a2 = createNode(a.i, a.x, a.y), b2 = createNode(b.i, b.x, b.y), an = a.next, bp = b.prev;\n    a.next = b;\n    b.prev = a;\n    a2.next = an;\n    an.prev = a2;\n    b2.next = a2;\n    a2.prev = b2;\n    bp.next = b2;\n    b2.prev = bp;\n    return b2;\n}\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    const p = createNode(i, x, y);\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\nfunction createNode(i, x, y) {\n    return {\n        i,\n        x,\n        y,\n        prev: null,\n        next: null,\n        z: 0,\n        prevZ: null,\n        nextZ: null,\n        steiner: false // indicates whether this is a steiner point\n    };\n}\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nfunction deviation(data, holeIndices, dim, triangles) {\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    let polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for(let i = 0, len = holeIndices.length; i < len; i++){\n            const start = holeIndices[i] * dim;\n            const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n    let trianglesArea = 0;\n    for(let i = 0; i < triangles.length; i += 3){\n        const a = triangles[i] * dim;\n        const b = triangles[i + 1] * dim;\n        const c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);\n}\nfunction signedArea(data, start, end, dim) {\n    let sum = 0;\n    for(let i = start, j = end - dim; i < end; i += dim){\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nfunction flatten(data) {\n    const vertices = [];\n    const holes = [];\n    const dimensions = data[0][0].length;\n    let holeIndex = 0;\n    let prevLen = 0;\n    for (const ring of data){\n        for (const p of ring){\n            for(let d = 0; d < dimensions; d++)vertices.push(p[d]);\n        }\n        if (prevLen) {\n            holeIndex += prevLen;\n            holes.push(holeIndex);\n        }\n        prevLen = ring.length;\n    }\n    return {\n        vertices,\n        holes,\n        dimensions\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZWFyY3V0L3NyYy9lYXJjdXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ2UsU0FBU0EsT0FBT0MsSUFBSSxFQUFFQyxXQUFXLEVBQUVDLE1BQU0sQ0FBQztJQUVyRCxNQUFNQyxXQUFXRixlQUFlQSxZQUFZRyxNQUFNO0lBQ2xELE1BQU1DLFdBQVdGLFdBQVdGLFdBQVcsQ0FBQyxFQUFFLEdBQUdDLE1BQU1GLEtBQUtJLE1BQU07SUFDOUQsSUFBSUUsWUFBWUMsV0FBV1AsTUFBTSxHQUFHSyxVQUFVSCxLQUFLO0lBQ25ELE1BQU1NLFlBQVksRUFBRTtJQUVwQixJQUFJLENBQUNGLGFBQWFBLFVBQVVHLElBQUksS0FBS0gsVUFBVUksSUFBSSxFQUFFLE9BQU9GO0lBRTVELElBQUlHLE1BQU1DLE1BQU1DO0lBRWhCLElBQUlWLFVBQVVHLFlBQVlRLGVBQWVkLE1BQU1DLGFBQWFLLFdBQVdKO0lBRXZFLDZGQUE2RjtJQUM3RixJQUFJRixLQUFLSSxNQUFNLEdBQUcsS0FBS0YsS0FBSztRQUN4QlMsT0FBT0k7UUFDUEgsT0FBT0c7UUFDUCxJQUFJQyxPQUFPLENBQUNEO1FBQ1osSUFBSUUsT0FBTyxDQUFDRjtRQUVaLElBQUssSUFBSUcsSUFBSWhCLEtBQUtnQixJQUFJYixVQUFVYSxLQUFLaEIsSUFBSztZQUN0QyxNQUFNaUIsSUFBSW5CLElBQUksQ0FBQ2tCLEVBQUU7WUFDakIsTUFBTUUsSUFBSXBCLElBQUksQ0FBQ2tCLElBQUksRUFBRTtZQUNyQixJQUFJQyxJQUFJUixNQUFNQSxPQUFPUTtZQUNyQixJQUFJQyxJQUFJUixNQUFNQSxPQUFPUTtZQUNyQixJQUFJRCxJQUFJSCxNQUFNQSxPQUFPRztZQUNyQixJQUFJQyxJQUFJSCxNQUFNQSxPQUFPRztRQUN6QjtRQUVBLGtHQUFrRztRQUNsR1AsVUFBVVEsS0FBS0MsR0FBRyxDQUFDTixPQUFPTCxNQUFNTSxPQUFPTDtRQUN2Q0MsVUFBVUEsWUFBWSxJQUFJLFFBQVFBLFVB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M0Q7UUFDQSxJQUFJRixTQUFTO1lBQ1RELGFBQWFDO1lBQ2JILE1BQU01RixJQUFJLENBQUM4RjtRQUNmO1FBQ0FDLFVBQVVDLEtBQUt2SSxNQUFNO0lBQ3pCO0lBQ0EsT0FBTztRQUFDa0k7UUFBVUM7UUFBT0M7SUFBVTtBQUN2QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvZWFyY3V0L3NyYy9lYXJjdXQuanM/NzMzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVhcmN1dChkYXRhLCBob2xlSW5kaWNlcywgZGltID0gMikge1xuXG4gICAgY29uc3QgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGg7XG4gICAgY29uc3Qgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgbGV0IG91dGVyTm9kZSA9IGxpbmtlZExpc3QoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSk7XG4gICAgY29uc3QgdHJpYW5nbGVzID0gW107XG5cbiAgICBpZiAoIW91dGVyTm9kZSB8fCBvdXRlck5vZGUubmV4dCA9PT0gb3V0ZXJOb2RlLnByZXYpIHJldHVybiB0cmlhbmdsZXM7XG5cbiAgICBsZXQgbWluWCwgbWluWSwgaW52U2l6ZTtcblxuICAgIGlmIChoYXNIb2xlcykgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKTtcblxuICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDgwICogZGltKSB7XG4gICAgICAgIG1pblggPSBJbmZpbml0eTtcbiAgICAgICAgbWluWSA9IEluZmluaXR5O1xuICAgICAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcbiAgICAgICAgbGV0IG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSkge1xuICAgICAgICAgICAgY29uc3QgeCA9IGRhdGFbaV07XG4gICAgICAgICAgICBjb25zdCB5ID0gZGF0YVtpICsgMV07XG4gICAgICAgICAgICBpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcbiAgICAgICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA+IG1heFkpIG1heFkgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWluWCwgbWluWSBhbmQgaW52U2l6ZSBhcmUgbGF0ZXIgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRzIGludG8gaW50ZWdlcnMgZm9yIHotb3JkZXIgY2FsY3VsYXRpb25cbiAgICAgICAgaW52U2l6ZSA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgICAgIGludlNpemUgPSBpbnZTaXplICE9PSAwID8gMzI3NjcgLyBpbnZTaXplIDogMDtcbiAgICB9XG5cbiAgICBlYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xufVxuXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbmZ1bmN0aW9uIGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UpIHtcbiAgICBsZXQgbGFzdDtcblxuICAgIGlmIChjbG9ja3dpc2UgPT09IChzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkgPiAwKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpIC8gZGltIHwgMCwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpIC8gZGltIHwgMCwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH1cblxuICAgIGlmIChsYXN0ICYmIGVxdWFscyhsYXN0LCBsYXN0Lm5leHQpKSB7XG4gICAgICAgIHJlbW92ZU5vZGUobGFzdCk7XG4gICAgICAgIGxhc3QgPSBsYXN0Lm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhc3Q7XG59XG5cbi8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoc3RhcnQsIGVuZCkge1xuICAgIGlmICghc3RhcnQpIHJldHVybiBzdGFydDtcbiAgICBpZiAoIWVuZCkgZW5kID0gc3RhcnQ7XG5cbiAgICBsZXQgcCA9IHN0YXJ0LFxuICAgICAgICBhZ2FpbjtcbiAgICBkbyB7XG4gICAgICAgIGFnYWluID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFwLnN0ZWluZXIgJiYgKGVxdWFscyhwLCBwLm5leHQpIHx8IGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHAgPSBlbmQgPSBwLnByZXY7XG4gICAgICAgICAgICBpZiAocCA9PT0gcC5uZXh0KSBicmVhaztcbiAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGFnYWluIHx8IHAgIT09IGVuZCk7XG5cbiAgICByZXR1cm4gZW5kO1xufVxuXG4vLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCBwYXNzKSB7XG4gICAgaWYgKCFlYXIpIHJldHVybjtcblxuICAgIC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbiAgICBpZiAoIXBhc3MgJiYgaW52U2l6ZSkgaW5kZXhDdXJ2ZShlYXIsIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgbGV0IHN0b3AgPSBlYXI7XG5cbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcbiAgICB3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBlYXIucHJldjtcbiAgICAgICAgY29uc3QgbmV4dCA9IGVhci5uZXh0O1xuXG4gICAgICAgIGlmIChpbnZTaXplID8gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSA6IGlzRWFyKGVhcikpIHtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYuaSwgZWFyLmksIG5leHQuaSk7IC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXG5cbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZWFyKTtcblxuICAgICAgICAgICAgLy8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGV4IGxlYWRzIHRvIGxlc3Mgc2xpdmVyIHRyaWFuZ2xlc1xuICAgICAgICAgICAgZWFyID0gbmV4dC5uZXh0O1xuICAgICAgICAgICAgc3RvcCA9IG5leHQubmV4dDtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBlYXIgPSBuZXh0O1xuXG4gICAgICAgIC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXG4gICAgICAgIGlmIChlYXIgPT09IHN0b3ApIHtcbiAgICAgICAgICAgIC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXG4gICAgICAgICAgICBpZiAoIXBhc3MpIHtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAxKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBkaWRuJ3Qgd29yaywgdHJ5IGN1cmluZyBhbGwgc21hbGwgc2VsZi1pbnRlcnNlY3Rpb25zIGxvY2FsbHlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcyk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDIpO1xuXG4gICAgICAgICAgICAvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgc3BsaXRFYXJjdXQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBjaGVjayB3aGV0aGVyIGEgcG9seWdvbiBub2RlIGZvcm1zIGEgdmFsaWQgZWFyIHdpdGggYWRqYWNlbnQgbm9kZXNcbmZ1bmN0aW9uIGlzRWFyKGVhcikge1xuICAgIGNvbnN0IGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcbiAgICBjb25zdCBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xuXG4gICAgLy8gdHJpYW5nbGUgYmJveFxuICAgIGNvbnN0IHgwID0gTWF0aC5taW4oYXgsIGJ4LCBjeCksXG4gICAgICAgIHkwID0gTWF0aC5taW4oYXksIGJ5LCBjeSksXG4gICAgICAgIHgxID0gTWF0aC5tYXgoYXgsIGJ4LCBjeCksXG4gICAgICAgIHkxID0gTWF0aC5tYXgoYXksIGJ5LCBjeSk7XG5cbiAgICBsZXQgcCA9IGMubmV4dDtcbiAgICB3aGlsZSAocCAhPT0gYSkge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGVFeGNlcHRGaXJzdChheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgY29uc3QgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICBjb25zdCBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xuXG4gICAgLy8gdHJpYW5nbGUgYmJveFxuICAgIGNvbnN0IHgwID0gTWF0aC5taW4oYXgsIGJ4LCBjeCksXG4gICAgICAgIHkwID0gTWF0aC5taW4oYXksIGJ5LCBjeSksXG4gICAgICAgIHgxID0gTWF0aC5tYXgoYXgsIGJ4LCBjeCksXG4gICAgICAgIHkxID0gTWF0aC5tYXgoYXksIGJ5LCBjeSk7XG5cbiAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuICAgIGNvbnN0IG1pblogPSB6T3JkZXIoeDAsIHkwLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSxcbiAgICAgICAgbWF4WiA9IHpPcmRlcih4MSwgeTEsIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgbGV0IHAgPSBlYXIucHJldlosXG4gICAgICAgIG4gPSBlYXIubmV4dFo7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBib3RoIGRpcmVjdGlvbnNcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWiAmJiBuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiYgcCAhPT0gYSAmJiBwICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGVFeGNlcHRGaXJzdChheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSkgJiYgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5wcmV2WjtcblxuICAgICAgICBpZiAobi54ID49IHgwICYmIG4ueCA8PSB4MSAmJiBuLnkgPj0geTAgJiYgbi55IDw9IHkxICYmIG4gIT09IGEgJiYgbiAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlRXhjZXB0Rmlyc3QoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgbi54LCBuLnkpICYmIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xuICAgICAgICBpZiAocC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmIHAgIT09IGEgJiYgcCAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlRXhjZXB0Rmlyc3QoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBpbmNyZWFzaW5nIHotb3JkZXJcbiAgICB3aGlsZSAobiAmJiBuLnogPD0gbWF4Wikge1xuICAgICAgICBpZiAobi54ID49IHgwICYmIG4ueCA8PSB4MSAmJiBuLnkgPj0geTAgJiYgbi55IDw9IHkxICYmIG4gIT09IGEgJiYgbiAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlRXhjZXB0Rmlyc3QoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgbi54LCBuLnkpICYmIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMpIHtcbiAgICBsZXQgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgY29uc3QgYSA9IHAucHJldixcbiAgICAgICAgICAgIGIgPSBwLm5leHQubmV4dDtcblxuICAgICAgICBpZiAoIWVxdWFscyhhLCBiKSAmJiBpbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpKSB7XG5cbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGEuaSwgcC5pLCBiLmkpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwLm5leHQpO1xuXG4gICAgICAgICAgICBwID0gc3RhcnQgPSBiO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGZpbHRlclBvaW50cyhwKTtcbn1cblxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXG4gICAgbGV0IGEgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGxldCBiID0gYS5uZXh0Lm5leHQ7XG4gICAgICAgIHdoaWxlIChiICE9PSBhLnByZXYpIHtcbiAgICAgICAgICAgIGlmIChhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgbGV0IGMgPSBzcGxpdFBvbHlnb24oYSwgYik7XG5cbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgICAgICAgICAgICAgIGEgPSBmaWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcbiAgICAgICAgICAgICAgICBjID0gZmlsdGVyUG9pbnRzKGMsIGMubmV4dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhLm5leHQ7XG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xufVxuXG4vLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pIHtcbiAgICBjb25zdCBxdWV1ZSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgIGNvbnN0IGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGxpc3QgPSBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UpO1xuICAgICAgICBpZiAobGlzdCA9PT0gbGlzdC5uZXh0KSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xuICAgICAgICBxdWV1ZS5wdXNoKGdldExlZnRtb3N0KGxpc3QpKTtcbiAgICB9XG5cbiAgICBxdWV1ZS5zb3J0KGNvbXBhcmVYWVNsb3BlKTtcblxuICAgIC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYWVNsb3BlKGEsIGIpIHtcbiAgICBsZXQgcmVzdWx0ID0gYS54IC0gYi54O1xuICAgIC8vIHdoZW4gdGhlIGxlZnQtbW9zdCBwb2ludCBvZiAyIGhvbGVzIG1lZXQgYXQgYSB2ZXJ0ZXgsIHNvcnQgdGhlIGhvbGVzIGNvdW50ZXJjbG9ja3dpc2Ugc28gdGhhdCB3aGVuIHdlIGZpbmRcbiAgICAvLyB0aGUgYnJpZGdlIHRvIHRoZSBvdXRlciBzaGVsbCBpcyBhbHdheXMgdGhlIHBvaW50IHRoYXQgdGhleSBtZWV0IGF0LlxuICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gYS55IC0gYi55O1xuICAgICAgICBpZiAocmVzdWx0ID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBhU2xvcGUgPSAoYS5uZXh0LnkgLSBhLnkpIC8gKGEubmV4dC54IC0gYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGJTbG9wZSA9IChiLm5leHQueSAtIGIueSkgLyAoYi5uZXh0LnggLSBiLngpO1xuICAgICAgICAgICAgcmVzdWx0ID0gYVNsb3BlIC0gYlNsb3BlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICBjb25zdCBicmlkZ2UgPSBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpO1xuICAgIGlmICghYnJpZGdlKSB7XG4gICAgICAgIHJldHVybiBvdXRlck5vZGU7XG4gICAgfVxuXG4gICAgY29uc3QgYnJpZGdlUmV2ZXJzZSA9IHNwbGl0UG9seWdvbihicmlkZ2UsIGhvbGUpO1xuXG4gICAgLy8gZmlsdGVyIGNvbGxpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG4gICAgZmlsdGVyUG9pbnRzKGJyaWRnZVJldmVyc2UsIGJyaWRnZVJldmVyc2UubmV4dCk7XG4gICAgcmV0dXJuIGZpbHRlclBvaW50cyhicmlkZ2UsIGJyaWRnZS5uZXh0KTtcbn1cblxuLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgbGV0IHAgPSBvdXRlck5vZGU7XG4gICAgY29uc3QgaHggPSBob2xlLng7XG4gICAgY29uc3QgaHkgPSBob2xlLnk7XG4gICAgbGV0IHF4ID0gLUluZmluaXR5O1xuICAgIGxldCBtO1xuXG4gICAgLy8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xuICAgIC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcbiAgICAvLyB1bmxlc3MgdGhleSBpbnRlcnNlY3QgYXQgYSB2ZXJ0ZXgsIHRoZW4gY2hvb3NlIHRoZSB2ZXJ0ZXhcbiAgICBpZiAoZXF1YWxzKGhvbGUsIHApKSByZXR1cm4gcDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChlcXVhbHMoaG9sZSwgcC5uZXh0KSkgcmV0dXJuIHAubmV4dDtcbiAgICAgICAgZWxzZSBpZiAoaHkgPD0gcC55ICYmIGh5ID49IHAubmV4dC55ICYmIHAubmV4dC55ICE9PSBwLnkpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBwLnggKyAoaHkgLSBwLnkpICogKHAubmV4dC54IC0gcC54KSAvIChwLm5leHQueSAtIHAueSk7XG4gICAgICAgICAgICBpZiAoeCA8PSBoeCAmJiB4ID4gcXgpIHtcbiAgICAgICAgICAgICAgICBxeCA9IHg7XG4gICAgICAgICAgICAgICAgbSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gaHgpIHJldHVybiBtOyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsZWZ0bW9zdCBlbmRwb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gb3V0ZXJOb2RlKTtcblxuICAgIGlmICghbSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XG4gICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcblxuICAgIGNvbnN0IHN0b3AgPSBtO1xuICAgIGNvbnN0IG14ID0gbS54O1xuICAgIGNvbnN0IG15ID0gbS55O1xuICAgIGxldCB0YW5NaW4gPSBJbmZpbml0eTtcblxuICAgIHAgPSBtO1xuXG4gICAgZG8ge1xuICAgICAgICBpZiAoaHggPj0gcC54ICYmIHAueCA+PSBteCAmJiBoeCAhPT0gcC54ICYmXG4gICAgICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55KSkge1xuXG4gICAgICAgICAgICBjb25zdCB0YW4gPSBNYXRoLmFicyhoeSAtIHAueSkgLyAoaHggLSBwLngpOyAvLyB0YW5nZW50aWFsXG5cbiAgICAgICAgICAgIGlmIChsb2NhbGx5SW5zaWRlKHAsIGhvbGUpICYmXG4gICAgICAgICAgICAgICAgKHRhbiA8IHRhbk1pbiB8fCAodGFuID09PSB0YW5NaW4gJiYgKHAueCA+IG0ueCB8fCAocC54ID09PSBtLnggJiYgc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkpKSkpKSB7XG4gICAgICAgICAgICAgICAgbSA9IHA7XG4gICAgICAgICAgICAgICAgdGFuTWluID0gdGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdG9wKTtcblxuICAgIHJldHVybiBtO1xufVxuXG4vLyB3aGV0aGVyIHNlY3RvciBpbiB2ZXJ0ZXggbSBjb250YWlucyBzZWN0b3IgaW4gdmVydGV4IHAgaW4gdGhlIHNhbWUgY29vcmRpbmF0ZXNcbmZ1bmN0aW9uIHNlY3RvckNvbnRhaW5zU2VjdG9yKG0sIHApIHtcbiAgICByZXR1cm4gYXJlYShtLnByZXYsIG0sIHAucHJldikgPCAwICYmIGFyZWEocC5uZXh0LCBtLCBtLm5leHQpIDwgMDtcbn1cblxuLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuZnVuY3Rpb24gaW5kZXhDdXJ2ZShzdGFydCwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIGxldCBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC56ID09PSAwKSBwLnogPSB6T3JkZXIocC54LCBwLnksIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICBwLnByZXZaID0gcC5wcmV2O1xuICAgICAgICBwLm5leHRaID0gcC5uZXh0O1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHAucHJldloubmV4dFogPSBudWxsO1xuICAgIHAucHJldlogPSBudWxsO1xuXG4gICAgc29ydExpbmtlZChwKTtcbn1cblxuLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cbi8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXG5mdW5jdGlvbiBzb3J0TGlua2VkKGxpc3QpIHtcbiAgICBsZXQgbnVtTWVyZ2VzO1xuICAgIGxldCBpblNpemUgPSAxO1xuXG4gICAgZG8ge1xuICAgICAgICBsZXQgcCA9IGxpc3Q7XG4gICAgICAgIGxldCBlO1xuICAgICAgICBsaXN0ID0gbnVsbDtcbiAgICAgICAgbGV0IHRhaWwgPSBudWxsO1xuICAgICAgICBudW1NZXJnZXMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBudW1NZXJnZXMrKztcbiAgICAgICAgICAgIGxldCBxID0gcDtcbiAgICAgICAgICAgIGxldCBwU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFNpemUrKztcbiAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICBpZiAoIXEpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHFTaXplID0gaW5TaXplO1xuXG4gICAgICAgICAgICB3aGlsZSAocFNpemUgPiAwIHx8IChxU2l6ZSA+IDAgJiYgcSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwU2l6ZSAhPT0gMCAmJiAocVNpemUgPT09IDAgfHwgIXEgfHwgcC56IDw9IHEueikpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFpbCkgdGFpbC5uZXh0WiA9IGU7XG4gICAgICAgICAgICAgICAgZWxzZSBsaXN0ID0gZTtcblxuICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xuICAgICAgICAgICAgICAgIHRhaWwgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gcTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWwubmV4dFogPSBudWxsO1xuICAgICAgICBpblNpemUgKj0gMjtcblxuICAgIH0gd2hpbGUgKG51bU1lcmdlcyA+IDEpO1xuXG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIGludmVyc2Ugb2YgdGhlIGxvbmdlciBzaWRlIG9mIGRhdGEgYmJveFxuZnVuY3Rpb24gek9yZGVyKHgsIHksIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gbm9uLW5lZ2F0aXZlIDE1LWJpdCBpbnRlZ2VyIHJhbmdlXG4gICAgeCA9ICh4IC0gbWluWCkgKiBpbnZTaXplIHwgMDtcbiAgICB5ID0gKHkgLSBtaW5ZKSAqIGludlNpemUgfCAwO1xuXG4gICAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vLyBmaW5kIHRoZSBsZWZ0bW9zdCBub2RlIG9mIGEgcG9seWdvbiByaW5nXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xuICAgIGxldCBwID0gc3RhcnQsXG4gICAgICAgIGxlZnRtb3N0ID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC54IDwgbGVmdG1vc3QueCB8fCAocC54ID09PSBsZWZ0bW9zdC54ICYmIHAueSA8IGxlZnRtb3N0LnkpKSBsZWZ0bW9zdCA9IHA7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGxlZnRtb3N0O1xufVxuXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XG4gICAgcmV0dXJuIChjeCAtIHB4KSAqIChheSAtIHB5KSA+PSAoYXggLSBweCkgKiAoY3kgLSBweSkgJiZcbiAgICAgICAgICAgKGF4IC0gcHgpICogKGJ5IC0gcHkpID49IChieCAtIHB4KSAqIChheSAtIHB5KSAmJlxuICAgICAgICAgICAoYnggLSBweCkgKiAoY3kgLSBweSkgPj0gKGN4IC0gcHgpICogKGJ5IC0gcHkpO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlIGJ1dCBmYWxzZSBpZiBpdHMgZXF1YWwgdG8gdGhlIGZpcnN0IHBvaW50IG9mIHRoZSB0cmlhbmdsZVxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlRXhjZXB0Rmlyc3QoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XG4gICAgcmV0dXJuICEoYXggPT09IHB4ICYmIGF5ID09PSBweSkgJiYgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSk7XG59XG5cbi8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcbiAgICByZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICFpbnRlcnNlY3RzUG9seWdvbihhLCBiKSAmJiAvLyBkb25lcyd0IGludGVyc2VjdCBvdGhlciBlZGdlc1xuICAgICAgICAgICAobG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpICYmIG1pZGRsZUluc2lkZShhLCBiKSAmJiAvLyBsb2NhbGx5IHZpc2libGVcbiAgICAgICAgICAgIChhcmVhKGEucHJldiwgYSwgYi5wcmV2KSB8fCBhcmVhKGEsIGIucHJldiwgYikpIHx8IC8vIGRvZXMgbm90IGNyZWF0ZSBvcHBvc2l0ZS1mYWNpbmcgc2VjdG9yc1xuICAgICAgICAgICAgZXF1YWxzKGEsIGIpICYmIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpID4gMCAmJiBhcmVhKGIucHJldiwgYiwgYi5uZXh0KSA+IDApOyAvLyBzcGVjaWFsIHplcm8tbGVuZ3RoIGNhc2Vcbn1cblxuLy8gc2lnbmVkIGFyZWEgb2YgYSB0cmlhbmdsZVxuZnVuY3Rpb24gYXJlYShwLCBxLCByKSB7XG4gICAgcmV0dXJuIChxLnkgLSBwLnkpICogKHIueCAtIHEueCkgLSAocS54IC0gcC54KSAqIChyLnkgLSBxLnkpO1xufVxuXG4vLyBjaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxuZnVuY3Rpb24gZXF1YWxzKHAxLCBwMikge1xuICAgIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcbmZ1bmN0aW9uIGludGVyc2VjdHMocDEsIHExLCBwMiwgcTIpIHtcbiAgICBjb25zdCBvMSA9IHNpZ24oYXJlYShwMSwgcTEsIHAyKSk7XG4gICAgY29uc3QgbzIgPSBzaWduKGFyZWEocDEsIHExLCBxMikpO1xuICAgIGNvbnN0IG8zID0gc2lnbihhcmVhKHAyLCBxMiwgcDEpKTtcbiAgICBjb25zdCBvNCA9IHNpZ24oYXJlYShwMiwgcTIsIHExKSk7XG5cbiAgICBpZiAobzEgIT09IG8yICYmIG8zICE9PSBvNCkgcmV0dXJuIHRydWU7IC8vIGdlbmVyYWwgY2FzZVxuXG4gICAgaWYgKG8xID09PSAwICYmIG9uU2VnbWVudChwMSwgcDIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcDIgYXJlIGNvbGxpbmVhciBhbmQgcDIgbGllcyBvbiBwMXExXG4gICAgaWYgKG8yID09PSAwICYmIG9uU2VnbWVudChwMSwgcTIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcTIgYXJlIGNvbGxpbmVhciBhbmQgcTIgbGllcyBvbiBwMXExXG4gICAgaWYgKG8zID09PSAwICYmIG9uU2VnbWVudChwMiwgcDEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcDEgYXJlIGNvbGxpbmVhciBhbmQgcDEgbGllcyBvbiBwMnEyXG4gICAgaWYgKG80ID09PSAwICYmIG9uU2VnbWVudChwMiwgcTEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcTEgYXJlIGNvbGxpbmVhciBhbmQgcTEgbGllcyBvbiBwMnEyXG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGZvciBjb2xsaW5lYXIgcG9pbnRzIHAsIHEsIHIsIGNoZWNrIGlmIHBvaW50IHEgbGllcyBvbiBzZWdtZW50IHByXG5mdW5jdGlvbiBvblNlZ21lbnQocCwgcSwgcikge1xuICAgIHJldHVybiBxLnggPD0gTWF0aC5tYXgocC54LCByLngpICYmIHEueCA+PSBNYXRoLm1pbihwLngsIHIueCkgJiYgcS55IDw9IE1hdGgubWF4KHAueSwgci55KSAmJiBxLnkgPj0gTWF0aC5taW4ocC55LCByLnkpO1xufVxuXG5mdW5jdGlvbiBzaWduKG51bSkge1xuICAgIHJldHVybiBudW0gPiAwID8gMSA6IG51bSA8IDAgPyAtMSA6IDA7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXG5mdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbihhLCBiKSB7XG4gICAgbGV0IHAgPSBhO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxuICAgICAgICAgICAgICAgIGludGVyc2VjdHMocCwgcC5uZXh0LCBhLCBiKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbG9jYWxseUluc2lkZShhLCBiKSB7XG4gICAgcmV0dXJuIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpIDwgMCA/XG4gICAgICAgIGFyZWEoYSwgYiwgYS5uZXh0KSA+PSAwICYmIGFyZWEoYSwgYS5wcmV2LCBiKSA+PSAwIDpcbiAgICAgICAgYXJlYShhLCBiLCBhLnByZXYpIDwgMCB8fCBhcmVhKGEsIGEubmV4dCwgYikgPCAwO1xufVxuXG4vLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIG1pZGRsZUluc2lkZShhLCBiKSB7XG4gICAgbGV0IHAgPSBhO1xuICAgIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgICBjb25zdCBweCA9IChhLnggKyBiLngpIC8gMjtcbiAgICBjb25zdCBweSA9IChhLnkgKyBiLnkpIC8gMjtcbiAgICBkbyB7XG4gICAgICAgIGlmICgoKHAueSA+IHB5KSAhPT0gKHAubmV4dC55ID4gcHkpKSAmJiBwLm5leHQueSAhPT0gcC55ICYmXG4gICAgICAgICAgICAgICAgKHB4IDwgKHAubmV4dC54IC0gcC54KSAqIChweSAtIHAueSkgLyAocC5uZXh0LnkgLSBwLnkpICsgcC54KSlcbiAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gaW5zaWRlO1xufVxuXG4vLyBsaW5rIHR3byBwb2x5Z29uIHZlcnRpY2VzIHdpdGggYSBicmlkZ2U7IGlmIHRoZSB2ZXJ0aWNlcyBiZWxvbmcgdG8gdGhlIHNhbWUgcmluZywgaXQgc3BsaXRzIHBvbHlnb24gaW50byB0d287XG4vLyBpZiBvbmUgYmVsb25ncyB0byB0aGUgb3V0ZXIgcmluZyBhbmQgYW5vdGhlciB0byBhIGhvbGUsIGl0IG1lcmdlcyBpdCBpbnRvIGEgc2luZ2xlIHJpbmdcbmZ1bmN0aW9uIHNwbGl0UG9seWdvbihhLCBiKSB7XG4gICAgY29uc3QgYTIgPSBjcmVhdGVOb2RlKGEuaSwgYS54LCBhLnkpLFxuICAgICAgICBiMiA9IGNyZWF0ZU5vZGUoYi5pLCBiLngsIGIueSksXG4gICAgICAgIGFuID0gYS5uZXh0LFxuICAgICAgICBicCA9IGIucHJldjtcblxuICAgIGEubmV4dCA9IGI7XG4gICAgYi5wcmV2ID0gYTtcblxuICAgIGEyLm5leHQgPSBhbjtcbiAgICBhbi5wcmV2ID0gYTI7XG5cbiAgICBiMi5uZXh0ID0gYTI7XG4gICAgYTIucHJldiA9IGIyO1xuXG4gICAgYnAubmV4dCA9IGIyO1xuICAgIGIyLnByZXYgPSBicDtcblxuICAgIHJldHVybiBiMjtcbn1cblxuLy8gY3JlYXRlIGEgbm9kZSBhbmQgb3B0aW9uYWxseSBsaW5rIGl0IHdpdGggcHJldmlvdXMgb25lIChpbiBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGluc2VydE5vZGUoaSwgeCwgeSwgbGFzdCkge1xuICAgIGNvbnN0IHAgPSBjcmVhdGVOb2RlKGksIHgsIHkpO1xuXG4gICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIHAucHJldiA9IHA7XG4gICAgICAgIHAubmV4dCA9IHA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBwLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgICAgIHAucHJldiA9IGxhc3Q7XG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gcDtcbiAgICAgICAgbGFzdC5uZXh0ID0gcDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUocCkge1xuICAgIHAubmV4dC5wcmV2ID0gcC5wcmV2O1xuICAgIHAucHJldi5uZXh0ID0gcC5uZXh0O1xuXG4gICAgaWYgKHAucHJldlopIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuICAgIGlmIChwLm5leHRaKSBwLm5leHRaLnByZXZaID0gcC5wcmV2Wjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZShpLCB4LCB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaSwgLy8gdmVydGV4IGluZGV4IGluIGNvb3JkaW5hdGVzIGFycmF5XG4gICAgICAgIHgsIHksIC8vIHZlcnRleCBjb29yZGluYXRlc1xuICAgICAgICBwcmV2OiBudWxsLCAvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0ZXggbm9kZXMgaW4gYSBwb2x5Z29uIHJpbmdcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgejogMCwgLy8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxuICAgICAgICBwcmV2WjogbnVsbCwgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuICAgICAgICBuZXh0WjogbnVsbCxcbiAgICAgICAgc3RlaW5lcjogZmFsc2UgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcbiAgICB9O1xufVxuXG4vLyByZXR1cm4gYSBwZXJjZW50YWdlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcG9seWdvbiBhcmVhIGFuZCBpdHMgdHJpYW5ndWxhdGlvbiBhcmVhO1xuLy8gdXNlZCB0byB2ZXJpZnkgY29ycmVjdG5lc3Mgb2YgdHJpYW5ndWxhdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGRldmlhdGlvbihkYXRhLCBob2xlSW5kaWNlcywgZGltLCB0cmlhbmdsZXMpIHtcbiAgICBjb25zdCBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aDtcbiAgICBjb25zdCBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcblxuICAgIGxldCBwb2x5Z29uQXJlYSA9IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSkpO1xuICAgIGlmIChoYXNIb2xlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgcG9seWdvbkFyZWEgLT0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCB0cmlhbmdsZXNBcmVhID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjb25zdCBhID0gdHJpYW5nbGVzW2ldICogZGltO1xuICAgICAgICBjb25zdCBiID0gdHJpYW5nbGVzW2kgKyAxXSAqIGRpbTtcbiAgICAgICAgY29uc3QgYyA9IHRyaWFuZ2xlc1tpICsgMl0gKiBkaW07XG4gICAgICAgIHRyaWFuZ2xlc0FyZWEgKz0gTWF0aC5hYnMoXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbY10pICogKGRhdGFbYiArIDFdIC0gZGF0YVthICsgMV0pIC1cbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtiXSkgKiAoZGF0YVtjICsgMV0gLSBkYXRhW2EgKyAxXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2x5Z29uQXJlYSA9PT0gMCAmJiB0cmlhbmdsZXNBcmVhID09PSAwID8gMCA6XG4gICAgICAgIE1hdGguYWJzKCh0cmlhbmdsZXNBcmVhIC0gcG9seWdvbkFyZWEpIC8gcG9seWdvbkFyZWEpO1xufVxuXG5mdW5jdGlvbiBzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0pIHtcbiAgICAgICAgc3VtICs9IChkYXRhW2pdIC0gZGF0YVtpXSkgKiAoZGF0YVtpICsgMV0gKyBkYXRhW2ogKyAxXSk7XG4gICAgICAgIGogPSBpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuXG4vLyB0dXJuIGEgcG9seWdvbiBpbiBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IGZvcm0gKGUuZy4gYXMgaW4gR2VvSlNPTikgaW50byBhIGZvcm0gRWFyY3V0IGFjY2VwdHNcbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuKGRhdGEpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuICAgIGNvbnN0IGhvbGVzID0gW107XG4gICAgY29uc3QgZGltZW5zaW9ucyA9IGRhdGFbMF1bMF0ubGVuZ3RoO1xuICAgIGxldCBob2xlSW5kZXggPSAwO1xuICAgIGxldCBwcmV2TGVuID0gMDtcblxuICAgIGZvciAoY29uc3QgcmluZyBvZiBkYXRhKSB7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiByaW5nKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbWVuc2lvbnM7IGQrKykgdmVydGljZXMucHVzaChwW2RdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldkxlbikge1xuICAgICAgICAgICAgaG9sZUluZGV4ICs9IHByZXZMZW47XG4gICAgICAgICAgICBob2xlcy5wdXNoKGhvbGVJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldkxlbiA9IHJpbmcubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4ge3ZlcnRpY2VzLCBob2xlcywgZGltZW5zaW9uc307XG59XG4iXSwibmFtZXMiOlsiZWFyY3V0IiwiZGF0YSIsImhvbGVJbmRpY2VzIiwiZGltIiwiaGFzSG9sZXMiLCJsZW5ndGgiLCJvdXRlckxlbiIsIm91dGVyTm9kZSIsImxpbmtlZExpc3QiLCJ0cmlhbmdsZXMiLCJuZXh0IiwicHJldiIsIm1pblgiLCJtaW5ZIiwiaW52U2l6ZSIsImVsaW1pbmF0ZUhvbGVzIiwiSW5maW5pdHkiLCJtYXhYIiwibWF4WSIsImkiLCJ4IiwieSIsIk1hdGgiLCJtYXgiLCJlYXJjdXRMaW5rZWQiLCJzdGFydCIsImVuZCIsImNsb2Nrd2lzZSIsImxhc3QiLCJzaWduZWRBcmVhIiwiaW5zZXJ0Tm9kZSIsImVxdWFscyIsInJlbW92ZU5vZGUiLCJmaWx0ZXJQb2ludHMiLCJwIiwiYWdhaW4iLCJzdGVpbmVyIiwiYXJlYSIsImVhciIsInBhc3MiLCJpbmRleEN1cnZlIiwic3RvcCIsImlzRWFySGFzaGVkIiwiaXNFYXIiLCJwdXNoIiwiY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyIsInNwbGl0RWFyY3V0IiwiYSIsImIiLCJjIiwiYXgiLCJieCIsImN4IiwiYXkiLCJieSIsImN5IiwieDAiLCJtaW4iLCJ5MCIsIngxIiwieTEiLCJwb2ludEluVHJpYW5nbGVFeGNlcHRGaXJzdCIsIm1pbloiLCJ6T3JkZXIiLCJtYXhaIiwicHJldloiLCJuIiwibmV4dFoiLCJ6IiwiaW50ZXJzZWN0cyIsImxvY2FsbHlJbnNpZGUiLCJpc1ZhbGlkRGlhZ29uYWwiLCJzcGxpdFBvbHlnb24iLCJxdWV1ZSIsImxlbiIsImxpc3QiLCJnZXRMZWZ0bW9zdCIsInNvcnQiLCJjb21wYXJlWFlTbG9wZSIsImVsaW1pbmF0ZUhvbGUiLCJyZXN1bHQiLCJhU2xvcGUiLCJiU2xvcGUiLCJob2xlIiwiYnJpZGdlIiwiZmluZEhvbGVCcmlkZ2UiLCJicmlkZ2VSZXZlcnNlIiwiaHgiLCJoeSIsInF4IiwibSIsIm14IiwibXkiLCJ0YW5NaW4iLCJwb2ludEluVHJpYW5nbGUiLCJ0YW4iLCJhYnMiLCJzZWN0b3JDb250YWluc1NlY3RvciIsInNvcnRMaW5rZWQiLCJudW1NZXJnZXMiLCJpblNpemUiLCJlIiwidGFpbCIsInEiLCJwU2l6ZSIsInFTaXplIiwibGVmdG1vc3QiLCJweCIsInB5IiwiaW50ZXJzZWN0c1BvbHlnb24iLCJtaWRkbGVJbnNpZGUiLCJyIiwicDEiLCJwMiIsInExIiwicTIiLCJvMSIsInNpZ24iLCJvMiIsIm8zIiwibzQiLCJvblNlZ21lbnQiLCJudW0iLCJpbnNpZGUiLCJhMiIsImNyZWF0ZU5vZGUiLCJiMiIsImFuIiwiYnAiLCJkZXZpYXRpb24iLCJwb2x5Z29uQXJlYSIsInRyaWFuZ2xlc0FyZWEiLCJzdW0iLCJqIiwiZmxhdHRlbiIsInZlcnRpY2VzIiwiaG9sZXMiLCJkaW1lbnNpb25zIiwiaG9sZUluZGV4IiwicHJldkxlbiIsInJpbmciLCJkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/earcut/src/earcut.js\n");

/***/ })

};
;