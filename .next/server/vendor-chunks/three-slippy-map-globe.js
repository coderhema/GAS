"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-slippy-map-globe";
exports.ids = ["vendor-chunks/three-slippy-map-globe"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-slippy-map-globe/dist/three-slippy-map-globe.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/three-slippy-map-globe/dist/three-slippy-map-globe.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ThreeSlippyMapGlobe)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var d3_octree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-octree */ \"(ssr)/./node_modules/d3-octree/src/octree.js\");\n/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-scale */ \"(ssr)/./node_modules/d3-scale/src/linear.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/projection/mercator.js\");\n\n\n\n\nfunction _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n    return n;\n}\nfunction _arrayWithHoles(r) {\n    if (Array.isArray(r)) return r;\n}\nfunction _arrayWithoutHoles(r) {\n    if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _assertClassBrand(e, t, n) {\n    if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n    throw new TypeError(\"Private element is not present on this object\");\n}\nfunction _assertThisInitialized(e) {\n    if (undefined === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return e;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _checkPrivateRedeclaration(e, t) {\n    if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _classPrivateFieldGet2(s, a) {\n    return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n    _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _classPrivateFieldSet2(s, a, r) {\n    return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _classPrivateMethodInitSpec(e, a) {\n    _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _defineProperties(e, r) {\n    for(var t = 0; t < r.length; t++){\n        var o = r[t];\n        o.enumerable = o.enumerable || false, o.configurable = true, \"value\" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n}\nfunction _createClass(e, r, t) {\n    return _defineProperties(e.prototype, r), Object.defineProperty(e, \"prototype\", {\n        writable: false\n    }), e;\n}\nfunction _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: true,\n        configurable: true,\n        writable: true\n    }) : e[r] = t, e;\n}\nfunction _getPrototypeOf(t) {\n    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {\n        return t.__proto__ || Object.getPrototypeOf(t);\n    }, _getPrototypeOf(t);\n}\nfunction _inherits(t, e) {\n    if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n    t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n            value: t,\n            writable: true,\n            configurable: true\n        }\n    }), Object.defineProperty(t, \"prototype\", {\n        writable: false\n    }), e && _setPrototypeOf(t, e);\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function() {\n        return !!t;\n    })();\n}\nfunction _iterableToArray(r) {\n    if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = true, o = false;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) ;\n            else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = true, n = r;\n        } finally{\n            try {\n                if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _possibleConstructorReturn(t, e) {\n    if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n    if (undefined !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n    return _assertThisInitialized(t);\n}\nfunction _setPrototypeOf(t, e) {\n    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {\n        return t.__proto__ = e, t;\n    }, _setPrototypeOf(t, e);\n}\nfunction _slicedToArray(r, e) {\n    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _toConsumableArray(r) {\n    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (undefined !== e) {\n        var i = e.call(t, r);\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return String(t);\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _unsupportedIterableToArray(r, a) {\n    if (r) {\n        if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n        var t = ({}).toString.call(r).slice(8, -1);\n        return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : undefined;\n    }\n}\nvar _materialDispose = function materialDispose(material) {\n    if (material instanceof Array) {\n        material.forEach(_materialDispose);\n    } else {\n        if (material.map) {\n            material.map.dispose();\n        }\n        material.dispose();\n    }\n};\nvar _deallocate = function deallocate(obj) {\n    if (obj.geometry) {\n        obj.geometry.dispose();\n    }\n    if (obj.material) {\n        _materialDispose(obj.material);\n    }\n    if (obj.texture) {\n        obj.texture.dispose();\n    }\n    if (obj.children) {\n        obj.children.forEach(_deallocate);\n    }\n};\nvar emptyObject = function emptyObject(obj) {\n    if (obj && obj.children) while(obj.children.length){\n        var childObj = obj.children[0];\n        obj.remove(childObj);\n        _deallocate(childObj);\n    }\n};\nfunction polar2Cartesian(lat, lng, r) {\n    var phi = (90 - lat) * Math.PI / 180;\n    var theta = (90 - lng) * Math.PI / 180;\n    return {\n        x: r * Math.sin(phi) * Math.cos(theta),\n        y: r * Math.cos(phi),\n        z: r * Math.sin(phi) * Math.sin(theta)\n    };\n}\nfunction cartesian2Polar(_ref) {\n    var x = _ref.x, y = _ref.y, z = _ref.z;\n    var r = Math.sqrt(x * x + y * y + z * z);\n    var phi = Math.acos(y / r);\n    var theta = Math.atan2(z, x);\n    return {\n        lat: 90 - phi * 180 / Math.PI,\n        lng: 90 - theta * 180 / Math.PI - (theta < -Math.PI / 2 ? 360 : 0),\n        // keep within [-180, 180] boundaries\n        r: r\n    };\n}\nfunction deg2Rad(deg) {\n    return deg * Math.PI / 180;\n}\nvar yMercatorScale = function yMercatorScale(y) {\n    return 1 - ((0,d3_geo__WEBPACK_IMPORTED_MODULE_0__.mercatorRaw)(0, (0.5 - y) * Math.PI)[1] / Math.PI + 1) / 2;\n};\nvar yMercatorScaleClamped = function yMercatorScaleClamped(y) {\n    return Math.max(0, Math.min(1, yMercatorScale(y)));\n};\nvar yMercatorScaleInvert = function yMercatorScaleInvert(y) {\n    return 0.5 - d3_geo__WEBPACK_IMPORTED_MODULE_0__.mercatorRaw.invert(0, (2 * (1 - y) - 1) * Math.PI)[1] / Math.PI;\n};\nvar convertMercatorUV = function convertMercatorUV(uvs) {\n    var y0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var y1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var offsetScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().domain([\n        1,\n        0\n    ]).range([\n        y0,\n        y1\n    ]).clamp(true);\n    var revOffsetScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().domain([\n        yMercatorScaleClamped(y0),\n        yMercatorScaleClamped(y1)\n    ]).range([\n        1,\n        0\n    ]).clamp(true);\n    var scale = function scale(v) {\n        return revOffsetScale(yMercatorScaleClamped(offsetScale(v)));\n    };\n    var arr = uvs.array;\n    for(var i = 0, len = arr.length; i < len; i += 2){\n        arr[i + 1] = scale(arr[i + 1]);\n    }\n    uvs.needsUpdate = true;\n};\nvar findTileXY = function findTileXY(level, isMercator, lng, lat) {\n    var gridSize = Math.pow(2, level);\n    var x = Math.max(0, Math.min(gridSize - 1, Math.floor((lng + 180) * gridSize / 360)));\n    var relY = (90 - lat) / 180;\n    isMercator && (relY = Math.max(0, Math.min(1, yMercatorScale(relY))));\n    var y = Math.floor(relY * gridSize);\n    return [\n        x,\n        y\n    ];\n};\nvar genTilesCoords = function genTilesCoords(level, isMercator) {\n    var x0 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var y0 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var _x1 = arguments.length > 4 ? arguments[4] : undefined;\n    var _y1 = arguments.length > 5 ? arguments[5] : undefined;\n    var tiles = [];\n    var gridSize = Math.pow(2, level);\n    var tileLngLen = 360 / gridSize;\n    var regTileLatLen = 180 / gridSize;\n    var x1 = _x1 === undefined ? gridSize - 1 : _x1;\n    var y1 = _y1 === undefined ? gridSize - 1 : _y1;\n    for(var x = x0, maxX = Math.min(gridSize - 1, x1); x <= maxX; x++){\n        for(var y = y0, maxY = Math.min(gridSize - 1, y1); y <= maxY; y++){\n            var reproY = y, tileLatLen = regTileLatLen;\n            if (isMercator) {\n                // lat needs reprojection, but stretch to cover poles\n                reproY = y === 0 ? y : yMercatorScaleInvert(y / gridSize) * gridSize;\n                var reproYEnd = y + 1 === gridSize ? y + 1 : yMercatorScaleInvert((y + 1) / gridSize) * gridSize;\n                tileLatLen = (reproYEnd - reproY) * 180 / gridSize;\n            }\n            // tile centroid coordinates\n            var lng = -180 + (x + 0.5) * tileLngLen;\n            var lat = 90 - (reproY * 180 / gridSize + tileLatLen / 2);\n            var latLen = tileLatLen; // lng is always constant among all tiles\n            tiles.push({\n                x: x,\n                y: y,\n                lng: lng,\n                lat: lat,\n                latLen: latLen\n            });\n        }\n    }\n    return tiles;\n};\nvar MAX_LEVEL_TO_RENDER_ALL_TILES = 6; // level 6 = 4096 tiles\nvar MAX_LEVEL_TO_BUILD_LOOKUP_OCTREE = 7; // octrees consume too much memory on higher levels, generate tiles on demand for those (based on globe surface distance) as the distortion is negligible\nvar TILE_SEARCH_RADIUS_CAMERA_DISTANCE = 3; // Euclidean distance factor, in units of camera distance to surface\nvar TILE_SEARCH_RADIUS_SURFACE_DISTANCE = 90; // in degrees on the globe surface, relative to camera altitude in globe radius units\nvar _radius = /*#__PURE__*/ new WeakMap();\nvar _isMercator = /*#__PURE__*/ new WeakMap();\nvar _tileUrl = /*#__PURE__*/ new WeakMap();\nvar _level = /*#__PURE__*/ new WeakMap();\nvar _tilesMeta = /*#__PURE__*/ new WeakMap();\nvar _isInView = /*#__PURE__*/ new WeakMap();\nvar _camera = /*#__PURE__*/ new WeakMap();\nvar _innerBackLayer = /*#__PURE__*/ new WeakMap();\nvar _ThreeSlippyMapGlobe_brand = /*#__PURE__*/ new WeakSet();\nvar ThreeSlippyMapGlobe = /*#__PURE__*/ function(_Group) {\n    function ThreeSlippyMapGlobe(radius) {\n        var _this;\n        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, tileUrl = _ref.tileUrl, _ref$minLevel = _ref.minLevel, minLevel = _ref$minLevel === undefined ? 0 : _ref$minLevel, _ref$maxLevel = _ref.maxLevel, maxLevel = _ref$maxLevel === undefined ? 17 : _ref$maxLevel, _ref$mercatorProjecti = _ref.mercatorProjection, mercatorProjection = _ref$mercatorProjecti === undefined ? true : _ref$mercatorProjecti;\n        _classCallCheck(this, ThreeSlippyMapGlobe);\n        _this = _callSuper(this, ThreeSlippyMapGlobe);\n        // Private methods\n        _classPrivateMethodInitSpec(_this, _ThreeSlippyMapGlobe_brand);\n        // Private attributes\n        _classPrivateFieldInitSpec(_this, _radius, undefined);\n        _classPrivateFieldInitSpec(_this, _isMercator, undefined);\n        _classPrivateFieldInitSpec(_this, _tileUrl, undefined);\n        _classPrivateFieldInitSpec(_this, _level, undefined);\n        _classPrivateFieldInitSpec(_this, _tilesMeta, {});\n        _classPrivateFieldInitSpec(_this, _isInView, undefined);\n        _classPrivateFieldInitSpec(_this, _camera, undefined);\n        _classPrivateFieldInitSpec(_this, _innerBackLayer, undefined);\n        _defineProperty(_this, \"minLevel\", undefined);\n        _defineProperty(_this, \"maxLevel\", undefined);\n        _defineProperty(_this, \"thresholds\", _toConsumableArray(new Array(30)).map(function(_, idx) {\n            return 8 / Math.pow(2, idx);\n        }));\n        // in terms of radius units\n        _defineProperty(_this, \"curvatureResolution\", 5);\n        // in degrees, affects number of vertices in tiles\n        _defineProperty(_this, \"tileMargin\", 0);\n        _defineProperty(_this, \"clearTiles\", function() {\n            Object.values(_classPrivateFieldGet2(_tilesMeta, _this)).forEach(function(l) {\n                l.forEach(function(d) {\n                    if (d.obj) {\n                        _this.remove(d.obj);\n                        emptyObject(d.obj);\n                        delete d.obj;\n                    }\n                });\n            });\n            _classPrivateFieldSet2(_tilesMeta, _this, {});\n        });\n        _classPrivateFieldSet2(_radius, _this, radius);\n        _this.tileUrl = tileUrl;\n        _classPrivateFieldSet2(_isMercator, _this, mercatorProjection);\n        _this.minLevel = minLevel;\n        _this.maxLevel = maxLevel;\n        _this.level = 0;\n        // Add protective black sphere just below surface to prevent any depth buffer anomalies\n        _this.add(_classPrivateFieldSet2(_innerBackLayer, _this, new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(_classPrivateFieldGet2(_radius, _this) * 0.99, 180, 90), new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n            color: 0x0\n        }))));\n        _classPrivateFieldGet2(_innerBackLayer, _this).visible = false;\n        _classPrivateFieldGet2(_innerBackLayer, _this).material.polygonOffset = true;\n        _classPrivateFieldGet2(_innerBackLayer, _this).material.polygonOffsetUnits = 3;\n        _classPrivateFieldGet2(_innerBackLayer, _this).material.polygonOffsetFactor = 1;\n        return _this;\n    }\n    _inherits(ThreeSlippyMapGlobe, _Group);\n    return _createClass(ThreeSlippyMapGlobe, [\n        {\n            key: \"tileUrl\",\n            get: // Public attributes\n            function get() {\n                return _classPrivateFieldGet2(_tileUrl, this);\n            },\n            set: function set(tileUrl) {\n                _classPrivateFieldSet2(_tileUrl, this, tileUrl);\n                this.updatePov(_classPrivateFieldGet2(_camera, this)); // update current view\n            }\n        },\n        {\n            key: \"level\",\n            get: function get() {\n                return _classPrivateFieldGet2(_level, this);\n            },\n            set: function set(level) {\n                var _this2 = this;\n                if (!_classPrivateFieldGet2(_tilesMeta, this)[level]) _assertClassBrand(_ThreeSlippyMapGlobe_brand, this, _buildMetaLevel).call(this, level);\n                var prevLevel = _classPrivateFieldGet2(_level, this);\n                _classPrivateFieldSet2(_level, this, level);\n                if (level === prevLevel || prevLevel === undefined) return; // nothing else to do\n                // Activate back layer for levels > 0, when there's !depthWrite tiles\n                _classPrivateFieldGet2(_innerBackLayer, this).visible = level > 0;\n                // Bring layer to front\n                _classPrivateFieldGet2(_tilesMeta, this)[level].forEach(function(d) {\n                    return d.obj && (d.obj.material.depthWrite = true);\n                });\n                // push lower layers to background\n                prevLevel < level && _classPrivateFieldGet2(_tilesMeta, this)[prevLevel].forEach(function(d) {\n                    return d.obj && (d.obj.material.depthWrite = false);\n                });\n                // Remove upper layers\n                if (prevLevel > level) {\n                    for(var l = level + 1; l <= prevLevel; l++){\n                        _classPrivateFieldGet2(_tilesMeta, this)[l] && _classPrivateFieldGet2(_tilesMeta, this)[l].forEach(function(d) {\n                            if (d.obj) {\n                                _this2.remove(d.obj);\n                                emptyObject(d.obj);\n                                delete d.obj;\n                            }\n                        });\n                    }\n                }\n                _assertClassBrand(_ThreeSlippyMapGlobe_brand, this, _fetchNeededTiles).call(this);\n            }\n        },\n        {\n            key: \"updatePov\",\n            value: function updatePov(camera) {\n                var _this3 = this;\n                if (!camera || !(camera instanceof three__WEBPACK_IMPORTED_MODULE_2__.Camera)) return;\n                _classPrivateFieldSet2(_camera, this, camera);\n                var frustum;\n                _classPrivateFieldSet2(_isInView, this, function(d) {\n                    if (!d.hullPnts) {\n                        // cached for next time to improve performance\n                        var lngLen = 360 / Math.pow(2, _this3.level);\n                        var lng = d.lng, lat = d.lat, latLen = d.latLen;\n                        var lng0 = lng - lngLen / 2;\n                        var lng1 = lng + lngLen / 2;\n                        var lat0 = lat - latLen / 2;\n                        var lat1 = lat + latLen / 2;\n                        d.hullPnts = [\n                            [\n                                lat,\n                                lng\n                            ],\n                            [\n                                lat0,\n                                lng0\n                            ],\n                            [\n                                lat1,\n                                lng0\n                            ],\n                            [\n                                lat0,\n                                lng1\n                            ],\n                            [\n                                lat1,\n                                lng1\n                            ]\n                        ].map(function(_ref2) {\n                            var _ref3 = _slicedToArray(_ref2, 2), lat = _ref3[0], lng = _ref3[1];\n                            return polar2Cartesian(lat, lng, _classPrivateFieldGet2(_radius, _this3));\n                        }).map(function(_ref4) {\n                            var x = _ref4.x, y = _ref4.y, z = _ref4.z;\n                            return new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(x, y, z);\n                        });\n                    }\n                    if (!frustum) {\n                        frustum = new three__WEBPACK_IMPORTED_MODULE_2__.Frustum();\n                        camera.updateMatrix();\n                        camera.updateMatrixWorld();\n                        frustum.setFromProjectionMatrix(new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));\n                    }\n                    return d.hullPnts.some(function(pos) {\n                        return frustum.containsPoint(pos.clone().applyMatrix4(_this3.matrixWorld));\n                    });\n                });\n                if (this.tileUrl) {\n                    var pov = camera.position.clone();\n                    var distToGlobeCenter = pov.distanceTo(this.getWorldPosition(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()));\n                    var cameraDistance = (distToGlobeCenter - _classPrivateFieldGet2(_radius, this)) / _classPrivateFieldGet2(_radius, this); // in units of globe radius\n                    var idx = this.thresholds.findIndex(function(t) {\n                        return t && t <= cameraDistance;\n                    });\n                    this.level = Math.min(this.maxLevel, Math.max(this.minLevel, idx < 0 ? this.thresholds.length : idx));\n                    _assertClassBrand(_ThreeSlippyMapGlobe_brand, this, _fetchNeededTiles).call(this);\n                }\n            }\n        }\n    ]);\n}(three__WEBPACK_IMPORTED_MODULE_2__.Group);\nfunction _buildMetaLevel(level) {\n    var _this4 = this;\n    if (level > MAX_LEVEL_TO_BUILD_LOOKUP_OCTREE) {\n        // Generate meta dynamically\n        _classPrivateFieldGet2(_tilesMeta, this)[level] = [];\n        return;\n    }\n    // Generate distance lookup octree\n    var levelMeta = _classPrivateFieldGet2(_tilesMeta, this)[level] = genTilesCoords(level, _classPrivateFieldGet2(_isMercator, this));\n    levelMeta.forEach(function(d) {\n        return d.centroid = polar2Cartesian(d.lat, d.lng, _classPrivateFieldGet2(_radius, _this4));\n    });\n    levelMeta.octree = (0,d3_octree__WEBPACK_IMPORTED_MODULE_3__[\"default\"])().x(function(d) {\n        return d.centroid.x;\n    }).y(function(d) {\n        return d.centroid.y;\n    }).z(function(d) {\n        return d.centroid.z;\n    }).addAll(levelMeta);\n}\nfunction _fetchNeededTiles() {\n    var _this5 = this;\n    if (!this.tileUrl || this.level === undefined || !_classPrivateFieldGet2(_tilesMeta, this).hasOwnProperty(this.level)) return;\n    // Safety if can't check in view tiles for higher levels\n    if (!_classPrivateFieldGet2(_isInView, this) && this.level > MAX_LEVEL_TO_RENDER_ALL_TILES) return;\n    var tiles = _classPrivateFieldGet2(_tilesMeta, this)[this.level];\n    if (_classPrivateFieldGet2(_camera, this)) {\n        // Pre-select tiles close to the camera\n        var povPos = this.worldToLocal(_classPrivateFieldGet2(_camera, this).position.clone());\n        if (tiles.octree) {\n            var _tiles$octree;\n            // Octree based on 3d positions is more accurate\n            var _povPos = this.worldToLocal(_classPrivateFieldGet2(_camera, this).position.clone());\n            var searchRadius = (_povPos.length() - _classPrivateFieldGet2(_radius, this)) * TILE_SEARCH_RADIUS_CAMERA_DISTANCE;\n            tiles = (_tiles$octree = tiles.octree).findAllWithinRadius.apply(_tiles$octree, _toConsumableArray(_povPos).concat([\n                searchRadius\n            ]));\n        } else {\n            // tiles populated dynamically\n            var povCoords = cartesian2Polar(povPos);\n            var searchRadiusLat = (povCoords.r / _classPrivateFieldGet2(_radius, this) - 1) * TILE_SEARCH_RADIUS_SURFACE_DISTANCE;\n            var searchRadiusLng = searchRadiusLat / Math.cos(deg2Rad(povCoords.lat)); // Distances in longitude degrees shrink towards the poles\n            var lngRange = [\n                povCoords.lng - searchRadiusLng,\n                povCoords.lng + searchRadiusLng\n            ];\n            var latRange = [\n                povCoords.lat + searchRadiusLat,\n                povCoords.lat - searchRadiusLat\n            ];\n            var _findTileXY = findTileXY(this.level, _classPrivateFieldGet2(_isMercator, this), lngRange[0], latRange[0]), _findTileXY2 = _slicedToArray(_findTileXY, 2), x0 = _findTileXY2[0], y0 = _findTileXY2[1];\n            var _findTileXY3 = findTileXY(this.level, _classPrivateFieldGet2(_isMercator, this), lngRange[1], latRange[1]), _findTileXY4 = _slicedToArray(_findTileXY3, 2), x1 = _findTileXY4[0], y1 = _findTileXY4[1];\n            !tiles.record && (tiles.record = {}); // Index gen tiles by XY\n            var r = tiles.record;\n            if (!r.hasOwnProperty(\"\".concat(Math.round((x0 + x1) / 2), \"_\").concat(Math.round((y0 + y1) / 2)))) {\n                // gen all found tiles if middle one is not in record\n                tiles = genTilesCoords(this.level, _classPrivateFieldGet2(_isMercator, this), x0, y0, x1, y1).map(function(d) {\n                    var k = \"\".concat(d.x, \"_\").concat(d.y);\n                    if (r.hasOwnProperty(k)) return r[k];\n                    r[k] = d;\n                    tiles.push(d);\n                    return d;\n                });\n            } else {\n                // gen only those missing, one by one\n                var selTiles = [];\n                for(var x = x0; x <= x1; x++){\n                    for(var y = y0; y <= y1; y++){\n                        var k = \"\".concat(x, \"_\").concat(y);\n                        if (!r.hasOwnProperty(k)) {\n                            r[k] = genTilesCoords(this.level, _classPrivateFieldGet2(_isMercator, this), x, y, x, y)[0];\n                            tiles.push(r[k]);\n                        }\n                        selTiles.push(r[k]);\n                    }\n                }\n                tiles = selTiles;\n            }\n        }\n    }\n    /*\n  console.log({\n    level: this.level,\n    totalObjs: this.children.length,\n    tilesFound: tiles.length,\n    tilesInView: tiles.filter(this.#isInView || (() => true)).length,\n    levelTiles: this.#tilesMeta[this.level].length,\n    fetched: this.#tilesMeta[this.level].filter(d => d.obj).length,\n    loading: this.#tilesMeta[this.level].filter(d => d.loading).length,\n  });\n  */ tiles.filter(function(d) {\n        return !d.obj;\n    }).filter(_classPrivateFieldGet2(_isInView, this) || function() {\n        return true;\n    }).forEach(function(d) {\n        var x = d.x, y = d.y, lng = d.lng, lat = d.lat, latLen = d.latLen;\n        var lngLen = 360 / Math.pow(2, _this5.level);\n        if (!d.obj) {\n            var width = lngLen * (1 - _this5.tileMargin);\n            var height = latLen * (1 - _this5.tileMargin);\n            var rotLng = deg2Rad(lng);\n            var rotLat = deg2Rad(-lat);\n            var tile = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(_classPrivateFieldGet2(_radius, _this5), Math.ceil(width / _this5.curvatureResolution), Math.ceil(height / _this5.curvatureResolution), deg2Rad(90 - width / 2) + rotLng, deg2Rad(width), deg2Rad(90 - height / 2) + rotLat, deg2Rad(height)), new three__WEBPACK_IMPORTED_MODULE_2__.MeshLambertMaterial());\n            if (_classPrivateFieldGet2(_isMercator, _this5)) {\n                var _map = [\n                    lat + latLen / 2,\n                    lat - latLen / 2\n                ].map(function(lat) {\n                    return 0.5 - lat / 180;\n                }), _map2 = _slicedToArray(_map, 2), _y = _map2[0], _y2 = _map2[1];\n                convertMercatorUV(tile.geometry.attributes.uv, _y, _y2);\n            }\n            d.obj = tile;\n        }\n        if (!d.loading) {\n            d.loading = true;\n            // Fetch tile image\n            new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader().load(_this5.tileUrl(x, y, _this5.level), function(texture) {\n                var tile = d.obj;\n                if (tile) {\n                    texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_2__.SRGBColorSpace;\n                    tile.material.map = texture;\n                    tile.material.color = null;\n                    tile.material.needsUpdate = true;\n                    _this5.add(tile);\n                }\n                d.loading = false;\n            });\n        }\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc2xpcHB5LW1hcC1nbG9iZS9kaXN0L3RocmVlLXNsaXBweS1tYXAtZ2xvYmUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQThKO0FBQzNIO0FBQ0k7QUFDQztBQUV4QyxTQUFTYyxrQkFBa0JDLENBQUMsRUFBRUMsQ0FBQztJQUM1QixTQUFRQSxLQUFLQSxJQUFJRCxFQUFFRSxNQUFNLEtBQU1ELENBQUFBLElBQUlELEVBQUVFLE1BQU07SUFDNUMsSUFBSyxJQUFJQyxJQUFJLEdBQUdDLElBQUlDLE1BQU1KLElBQUlFLElBQUlGLEdBQUdFLElBQUtDLENBQUMsQ0FBQ0QsRUFBRSxHQUFHSCxDQUFDLENBQUNHLEVBQUU7SUFDckQsT0FBT0M7QUFDVDtBQUNBLFNBQVNFLGdCQUFnQk4sQ0FBQztJQUN4QixJQUFJSyxNQUFNRSxPQUFPLENBQUNQLElBQUksT0FBT0E7QUFDL0I7QUFDQSxTQUFTUSxtQkFBbUJSLENBQUM7SUFDM0IsSUFBSUssTUFBTUUsT0FBTyxDQUFDUCxJQUFJLE9BQU9ELGtCQUFrQkM7QUFDakQ7QUFDQSxTQUFTUyxrQkFBa0JOLENBQUMsRUFBRU8sQ0FBQyxFQUFFTixDQUFDO0lBQ2hDLElBQUksY0FBYyxPQUFPRCxJQUFJQSxNQUFNTyxJQUFJUCxFQUFFUSxHQUFHLENBQUNELElBQUksT0FBT0UsVUFBVVYsTUFBTSxHQUFHLElBQUlRLElBQUlOO0lBQ25GLE1BQU0sSUFBSVMsVUFBVTtBQUN0QjtBQUNBLFNBQVNDLHVCQUF1QlgsQ0FBQztJQUMvQixJQUFJWSxjQUFjWixHQUFHLE1BQU0sSUFBSWEsZUFBZTtJQUM5QyxPQUFPYjtBQUNUO0FBQ0EsU0FBU2MsV0FBV1AsQ0FBQyxFQUFFUSxDQUFDLEVBQUVmLENBQUM7SUFDekIsT0FBT2UsSUFBSUMsZ0JBQWdCRCxJQUFJRSwyQkFBMkJWLEdBQUdXLDhCQUE4QkMsUUFBUUMsU0FBUyxDQUFDTCxHQUFHLEVBQUUsRUFBRUMsZ0JBQWdCVCxHQUFH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QU8sRUFBRTtZQUNkckYsRUFBRXFGLE9BQU8sR0FBRztZQUVaLG1CQUFtQjtZQUNuQixJQUFJdlIsZ0RBQWFBLEdBQUd3UixJQUFJLENBQUN0QyxPQUFPMUQsT0FBTyxDQUFDekUsR0FBR0csR0FBR2dJLE9BQU9qRyxLQUFLLEdBQUcsU0FBVTlDLE9BQU87Z0JBQzVFLElBQUkySyxPQUFPNUUsRUFBRWpHLEdBQUc7Z0JBQ2hCLElBQUk2SyxNQUFNO29CQUNSM0ssUUFBUXNMLFVBQVUsR0FBR3hSLGlEQUFjQTtvQkFDbkM2USxLQUFLbkwsUUFBUSxDQUFDRSxHQUFHLEdBQUdNO29CQUNwQjJLLEtBQUtuTCxRQUFRLENBQUN3RyxLQUFLLEdBQUc7b0JBQ3RCMkUsS0FBS25MLFFBQVEsQ0FBQ29ELFdBQVcsR0FBRztvQkFDNUJtRyxPQUFPek0sR0FBRyxDQUFDcU87Z0JBQ2I7Z0JBQ0E1RSxFQUFFcUYsT0FBTyxHQUFHO1lBQ2Q7UUFDRjtJQUNGO0FBQ0Y7QUFFMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3RocmVlLXNsaXBweS1tYXAtZ2xvYmUvZGlzdC90aHJlZS1zbGlwcHktbWFwLWdsb2JlLm1qcz9kYjFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdyb3VwLCBNZXNoLCBTcGhlcmVHZW9tZXRyeSwgTWVzaEJhc2ljTWF0ZXJpYWwsIENhbWVyYSwgVmVjdG9yMywgRnJ1c3R1bSwgTWF0cml4NCwgTWVzaExhbWJlcnRNYXRlcmlhbCwgVGV4dHVyZUxvYWRlciwgU1JHQkNvbG9yU3BhY2UgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBvY3RyZWUgfSBmcm9tICdkMy1vY3RyZWUnO1xuaW1wb3J0IHsgc2NhbGVMaW5lYXIgfSBmcm9tICdkMy1zY2FsZSc7XG5pbXBvcnQgeyBnZW9NZXJjYXRvclJhdyB9IGZyb20gJ2QzLWdlbyc7XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHtcbiAgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpO1xuICBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikge1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMocikge1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIpO1xufVxuZnVuY3Rpb24gX2Fzc2VydENsYXNzQnJhbmQoZSwgdCwgbikge1xuICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBlID8gZSA9PT0gdCA6IGUuaGFzKHQpKSByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0IDogbjtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgZWxlbWVudCBpcyBub3QgcHJlc2VudCBvbiB0aGlzIG9iamVjdFwiKTtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoZSkge1xuICBpZiAodW5kZWZpbmVkID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7XG4gIHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpO1xufVxuZnVuY3Rpb24gX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24oZSwgdCkge1xuICBpZiAodC5oYXMoZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgaW5pdGlhbGl6ZSB0aGUgc2FtZSBwcml2YXRlIGVsZW1lbnRzIHR3aWNlIG9uIGFuIG9iamVjdFwiKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7XG4gIGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIocywgYSkge1xuICByZXR1cm4gcy5nZXQoX2Fzc2VydENsYXNzQnJhbmQocywgYSkpO1xufVxuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMoZSwgdCwgYSkge1xuICBfY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbihlLCB0KSwgdC5zZXQoZSwgYSk7XG59XG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRTZXQyKHMsIGEsIHIpIHtcbiAgcmV0dXJuIHMuc2V0KF9hc3NlcnRDbGFzc0JyYW5kKHMsIGEpLCByKSwgcjtcbn1cbmZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVNZXRob2RJbml0U3BlYyhlLCBhKSB7XG4gIF9jaGVja1ByaXZhdGVSZWRlY2xhcmF0aW9uKGUsIGEpLCBhLmFkZChlKTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG8gPSByW3RdO1xuICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCBmYWxzZSwgby5jb25maWd1cmFibGUgPSB0cnVlLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9IHRydWUpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHtcbiAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuICByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgdmFsdWU6IHQsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSkgOiBlW3JdID0gdCwgZTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZih0KSB7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO1xuICB9LCBfZ2V0UHJvdG90eXBlT2YodCk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHModCwgZSkge1xuICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHQsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLCBlICYmIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICB9IGNhdGNoICh0KSB7fVxuICByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdDtcbiAgfSkoKTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkocikge1xuICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gcltTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gcltcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKHIpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9IHRydWUsXG4gICAgICBvID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIDsgZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBvID0gdHJ1ZSwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGUpIHtcbiAgaWYgKGUgJiYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7XG4gIGlmICh1bmRlZmluZWQgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQodCk7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YodCwgZSkge1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgcmV0dXJuIHQuX19wcm90b19fID0gZSwgdDtcbiAgfSwgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xufVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5KHIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh1bmRlZmluZWQgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoU3RyaW5nICkodCk7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7XG4gIGlmIChyKSB7XG4gICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTtcbiAgICB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpO1xuICAgIHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbnZhciBfbWF0ZXJpYWxEaXNwb3NlID0gZnVuY3Rpb24gbWF0ZXJpYWxEaXNwb3NlKG1hdGVyaWFsKSB7XG4gIGlmIChtYXRlcmlhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgbWF0ZXJpYWwuZm9yRWFjaChfbWF0ZXJpYWxEaXNwb3NlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobWF0ZXJpYWwubWFwKSB7XG4gICAgICBtYXRlcmlhbC5tYXAuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBtYXRlcmlhbC5kaXNwb3NlKCk7XG4gIH1cbn07XG52YXIgX2RlYWxsb2NhdGUgPSBmdW5jdGlvbiBkZWFsbG9jYXRlKG9iaikge1xuICBpZiAob2JqLmdlb21ldHJ5KSB7XG4gICAgb2JqLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgfVxuICBpZiAob2JqLm1hdGVyaWFsKSB7XG4gICAgX21hdGVyaWFsRGlzcG9zZShvYmoubWF0ZXJpYWwpO1xuICB9XG4gIGlmIChvYmoudGV4dHVyZSkge1xuICAgIG9iai50ZXh0dXJlLmRpc3Bvc2UoKTtcbiAgfVxuICBpZiAob2JqLmNoaWxkcmVuKSB7XG4gICAgb2JqLmNoaWxkcmVuLmZvckVhY2goX2RlYWxsb2NhdGUpO1xuICB9XG59O1xudmFyIGVtcHR5T2JqZWN0ID0gZnVuY3Rpb24gZW1wdHlPYmplY3Qob2JqKSB7XG4gIGlmIChvYmogJiYgb2JqLmNoaWxkcmVuKSB3aGlsZSAob2JqLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBjaGlsZE9iaiA9IG9iai5jaGlsZHJlblswXTtcbiAgICBvYmoucmVtb3ZlKGNoaWxkT2JqKTtcbiAgICBfZGVhbGxvY2F0ZShjaGlsZE9iaik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBvbGFyMkNhcnRlc2lhbihsYXQsIGxuZywgcikge1xuICB2YXIgcGhpID0gKDkwIC0gbGF0KSAqIE1hdGguUEkgLyAxODA7XG4gIHZhciB0aGV0YSA9ICg5MCAtIGxuZykgKiBNYXRoLlBJIC8gMTgwO1xuICByZXR1cm4ge1xuICAgIHg6IHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5jb3ModGhldGEpLFxuICAgIHk6IHIgKiBNYXRoLmNvcyhwaGkpLFxuICAgIHo6IHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5zaW4odGhldGEpXG4gIH07XG59XG5mdW5jdGlvbiBjYXJ0ZXNpYW4yUG9sYXIoX3JlZikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICB5ID0gX3JlZi55LFxuICAgIHogPSBfcmVmLno7XG4gIHZhciByID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIHZhciBwaGkgPSBNYXRoLmFjb3MoeSAvIHIpO1xuICB2YXIgdGhldGEgPSBNYXRoLmF0YW4yKHosIHgpO1xuICByZXR1cm4ge1xuICAgIGxhdDogOTAgLSBwaGkgKiAxODAgLyBNYXRoLlBJLFxuICAgIGxuZzogOTAgLSB0aGV0YSAqIDE4MCAvIE1hdGguUEkgLSAodGhldGEgPCAtTWF0aC5QSSAvIDIgPyAzNjAgOiAwKSxcbiAgICAvLyBrZWVwIHdpdGhpbiBbLTE4MCwgMTgwXSBib3VuZGFyaWVzXG4gICAgcjogclxuICB9O1xufVxuZnVuY3Rpb24gZGVnMlJhZChkZWcpIHtcbiAgcmV0dXJuIGRlZyAqIE1hdGguUEkgLyAxODA7XG59XG5cbnZhciB5TWVyY2F0b3JTY2FsZSA9IGZ1bmN0aW9uIHlNZXJjYXRvclNjYWxlKHkpIHtcbiAgcmV0dXJuIDEgLSAoZ2VvTWVyY2F0b3JSYXcoMCwgKDAuNSAtIHkpICogTWF0aC5QSSlbMV0gLyBNYXRoLlBJICsgMSkgLyAyO1xufTtcbnZhciB5TWVyY2F0b3JTY2FsZUNsYW1wZWQgPSBmdW5jdGlvbiB5TWVyY2F0b3JTY2FsZUNsYW1wZWQoeSkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgeU1lcmNhdG9yU2NhbGUoeSkpKTtcbn07XG52YXIgeU1lcmNhdG9yU2NhbGVJbnZlcnQgPSBmdW5jdGlvbiB5TWVyY2F0b3JTY2FsZUludmVydCh5KSB7XG4gIHJldHVybiAwLjUgLSBnZW9NZXJjYXRvclJhdy5pbnZlcnQoMCwgKDIgKiAoMSAtIHkpIC0gMSkgKiBNYXRoLlBJKVsxXSAvIE1hdGguUEk7XG59O1xudmFyIGNvbnZlcnRNZXJjYXRvclVWID0gZnVuY3Rpb24gY29udmVydE1lcmNhdG9yVVYodXZzKSB7XG4gIHZhciB5MCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIHkxID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICB2YXIgb2Zmc2V0U2NhbGUgPSBzY2FsZUxpbmVhcigpLmRvbWFpbihbMSwgMF0pLnJhbmdlKFt5MCwgeTFdKS5jbGFtcCh0cnVlKTtcbiAgdmFyIHJldk9mZnNldFNjYWxlID0gc2NhbGVMaW5lYXIoKS5kb21haW4oW3lNZXJjYXRvclNjYWxlQ2xhbXBlZCh5MCksIHlNZXJjYXRvclNjYWxlQ2xhbXBlZCh5MSldKS5yYW5nZShbMSwgMF0pLmNsYW1wKHRydWUpO1xuICB2YXIgc2NhbGUgPSBmdW5jdGlvbiBzY2FsZSh2KSB7XG4gICAgcmV0dXJuIHJldk9mZnNldFNjYWxlKHlNZXJjYXRvclNjYWxlQ2xhbXBlZChvZmZzZXRTY2FsZSh2KSkpO1xuICB9O1xuICB2YXIgYXJyID0gdXZzLmFycmF5O1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgYXJyW2kgKyAxXSA9IHNjYWxlKGFycltpICsgMV0pO1xuICB9XG4gIHV2cy5uZWVkc1VwZGF0ZSA9IHRydWU7XG59O1xuXG52YXIgZmluZFRpbGVYWSA9IGZ1bmN0aW9uIGZpbmRUaWxlWFkobGV2ZWwsIGlzTWVyY2F0b3IsIGxuZywgbGF0KSB7XG4gIHZhciBncmlkU2l6ZSA9IE1hdGgucG93KDIsIGxldmVsKTtcbiAgdmFyIHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihncmlkU2l6ZSAtIDEsIE1hdGguZmxvb3IoKGxuZyArIDE4MCkgKiBncmlkU2l6ZSAvIDM2MCkpKTtcbiAgdmFyIHJlbFkgPSAoOTAgLSBsYXQpIC8gMTgwO1xuICBpc01lcmNhdG9yICYmIChyZWxZID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgeU1lcmNhdG9yU2NhbGUocmVsWSkpKSk7XG4gIHZhciB5ID0gTWF0aC5mbG9vcihyZWxZICogZ3JpZFNpemUpO1xuICByZXR1cm4gW3gsIHldO1xufTtcbnZhciBnZW5UaWxlc0Nvb3JkcyA9IGZ1bmN0aW9uIGdlblRpbGVzQ29vcmRzKGxldmVsLCBpc01lcmNhdG9yKSB7XG4gIHZhciB4MCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgdmFyIHkwID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICB2YXIgX3gxID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gIHZhciBfeTEgPSBhcmd1bWVudHMubGVuZ3RoID4gNSA/IGFyZ3VtZW50c1s1XSA6IHVuZGVmaW5lZDtcbiAgdmFyIHRpbGVzID0gW107XG4gIHZhciBncmlkU2l6ZSA9IE1hdGgucG93KDIsIGxldmVsKTtcbiAgdmFyIHRpbGVMbmdMZW4gPSAzNjAgLyBncmlkU2l6ZTtcbiAgdmFyIHJlZ1RpbGVMYXRMZW4gPSAxODAgLyBncmlkU2l6ZTtcbiAgdmFyIHgxID0gX3gxID09PSB1bmRlZmluZWQgPyBncmlkU2l6ZSAtIDEgOiBfeDE7XG4gIHZhciB5MSA9IF95MSA9PT0gdW5kZWZpbmVkID8gZ3JpZFNpemUgLSAxIDogX3kxO1xuICBmb3IgKHZhciB4ID0geDAsIG1heFggPSBNYXRoLm1pbihncmlkU2l6ZSAtIDEsIHgxKTsgeCA8PSBtYXhYOyB4KyspIHtcbiAgICBmb3IgKHZhciB5ID0geTAsIG1heFkgPSBNYXRoLm1pbihncmlkU2l6ZSAtIDEsIHkxKTsgeSA8PSBtYXhZOyB5KyspIHtcbiAgICAgIHZhciByZXByb1kgPSB5LFxuICAgICAgICB0aWxlTGF0TGVuID0gcmVnVGlsZUxhdExlbjtcbiAgICAgIGlmIChpc01lcmNhdG9yKSB7XG4gICAgICAgIC8vIGxhdCBuZWVkcyByZXByb2plY3Rpb24sIGJ1dCBzdHJldGNoIHRvIGNvdmVyIHBvbGVzXG4gICAgICAgIHJlcHJvWSA9IHkgPT09IDAgPyB5IDogeU1lcmNhdG9yU2NhbGVJbnZlcnQoeSAvIGdyaWRTaXplKSAqIGdyaWRTaXplO1xuICAgICAgICB2YXIgcmVwcm9ZRW5kID0geSArIDEgPT09IGdyaWRTaXplID8geSArIDEgOiB5TWVyY2F0b3JTY2FsZUludmVydCgoeSArIDEpIC8gZ3JpZFNpemUpICogZ3JpZFNpemU7XG4gICAgICAgIHRpbGVMYXRMZW4gPSAocmVwcm9ZRW5kIC0gcmVwcm9ZKSAqIDE4MCAvIGdyaWRTaXplO1xuICAgICAgfVxuXG4gICAgICAvLyB0aWxlIGNlbnRyb2lkIGNvb3JkaW5hdGVzXG4gICAgICB2YXIgbG5nID0gLTE4MCArICh4ICsgMC41KSAqIHRpbGVMbmdMZW47XG4gICAgICB2YXIgbGF0ID0gOTAgLSAocmVwcm9ZICogMTgwIC8gZ3JpZFNpemUgKyB0aWxlTGF0TGVuIC8gMik7XG4gICAgICB2YXIgbGF0TGVuID0gdGlsZUxhdExlbjsgLy8gbG5nIGlzIGFsd2F5cyBjb25zdGFudCBhbW9uZyBhbGwgdGlsZXNcblxuICAgICAgdGlsZXMucHVzaCh7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIGxuZzogbG5nLFxuICAgICAgICBsYXQ6IGxhdCxcbiAgICAgICAgbGF0TGVuOiBsYXRMZW5cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGlsZXM7XG59O1xuXG52YXIgTUFYX0xFVkVMX1RPX1JFTkRFUl9BTExfVElMRVMgPSA2OyAvLyBsZXZlbCA2ID0gNDA5NiB0aWxlc1xudmFyIE1BWF9MRVZFTF9UT19CVUlMRF9MT09LVVBfT0NUUkVFID0gNzsgLy8gb2N0cmVlcyBjb25zdW1lIHRvbyBtdWNoIG1lbW9yeSBvbiBoaWdoZXIgbGV2ZWxzLCBnZW5lcmF0ZSB0aWxlcyBvbiBkZW1hbmQgZm9yIHRob3NlIChiYXNlZCBvbiBnbG9iZSBzdXJmYWNlIGRpc3RhbmNlKSBhcyB0aGUgZGlzdG9ydGlvbiBpcyBuZWdsaWdpYmxlXG52YXIgVElMRV9TRUFSQ0hfUkFESVVTX0NBTUVSQV9ESVNUQU5DRSA9IDM7IC8vIEV1Y2xpZGVhbiBkaXN0YW5jZSBmYWN0b3IsIGluIHVuaXRzIG9mIGNhbWVyYSBkaXN0YW5jZSB0byBzdXJmYWNlXG52YXIgVElMRV9TRUFSQ0hfUkFESVVTX1NVUkZBQ0VfRElTVEFOQ0UgPSA5MDsgLy8gaW4gZGVncmVlcyBvbiB0aGUgZ2xvYmUgc3VyZmFjZSwgcmVsYXRpdmUgdG8gY2FtZXJhIGFsdGl0dWRlIGluIGdsb2JlIHJhZGl1cyB1bml0c1xudmFyIF9yYWRpdXMgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBfaXNNZXJjYXRvciA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xudmFyIF90aWxlVXJsID0gLyojX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG52YXIgX2xldmVsID0gLyojX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG52YXIgX3RpbGVzTWV0YSA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xudmFyIF9pc0luVmlldyA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xudmFyIF9jYW1lcmEgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBfaW5uZXJCYWNrTGF5ZXIgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBfVGhyZWVTbGlwcHlNYXBHbG9iZV9icmFuZCA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha1NldCgpO1xudmFyIFRocmVlU2xpcHB5TWFwR2xvYmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Hcm91cCkge1xuICBmdW5jdGlvbiBUaHJlZVNsaXBweU1hcEdsb2JlKHJhZGl1cykge1xuICAgIHZhciBfdGhpcztcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICB0aWxlVXJsID0gX3JlZi50aWxlVXJsLFxuICAgICAgX3JlZiRtaW5MZXZlbCA9IF9yZWYubWluTGV2ZWwsXG4gICAgICBtaW5MZXZlbCA9IF9yZWYkbWluTGV2ZWwgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJG1pbkxldmVsLFxuICAgICAgX3JlZiRtYXhMZXZlbCA9IF9yZWYubWF4TGV2ZWwsXG4gICAgICBtYXhMZXZlbCA9IF9yZWYkbWF4TGV2ZWwgPT09IHVuZGVmaW5lZCA/IDE3IDogX3JlZiRtYXhMZXZlbCxcbiAgICAgIF9yZWYkbWVyY2F0b3JQcm9qZWN0aSA9IF9yZWYubWVyY2F0b3JQcm9qZWN0aW9uLFxuICAgICAgbWVyY2F0b3JQcm9qZWN0aW9uID0gX3JlZiRtZXJjYXRvclByb2plY3RpID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZiRtZXJjYXRvclByb2plY3RpO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaHJlZVNsaXBweU1hcEdsb2JlKTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgVGhyZWVTbGlwcHlNYXBHbG9iZSk7XG4gICAgLy8gUHJpdmF0ZSBtZXRob2RzXG4gICAgX2NsYXNzUHJpdmF0ZU1ldGhvZEluaXRTcGVjKF90aGlzLCBfVGhyZWVTbGlwcHlNYXBHbG9iZV9icmFuZCk7XG4gICAgLy8gUHJpdmF0ZSBhdHRyaWJ1dGVzXG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMoX3RoaXMsIF9yYWRpdXMsIHVuZGVmaW5lZCk7XG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMoX3RoaXMsIF9pc01lcmNhdG9yLCB1bmRlZmluZWQpO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKF90aGlzLCBfdGlsZVVybCwgdW5kZWZpbmVkKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyhfdGhpcywgX2xldmVsLCB1bmRlZmluZWQpO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKF90aGlzLCBfdGlsZXNNZXRhLCB7fSk7XG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMoX3RoaXMsIF9pc0luVmlldywgdW5kZWZpbmVkKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyhfdGhpcywgX2NhbWVyYSwgdW5kZWZpbmVkKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyhfdGhpcywgX2lubmVyQmFja0xheWVyLCB1bmRlZmluZWQpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJtaW5MZXZlbFwiLCB1bmRlZmluZWQpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJtYXhMZXZlbFwiLCB1bmRlZmluZWQpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ0aHJlc2hvbGRzXCIsIF90b0NvbnN1bWFibGVBcnJheShuZXcgQXJyYXkoMzApKS5tYXAoZnVuY3Rpb24gKF8sIGlkeCkge1xuICAgICAgcmV0dXJuIDggLyBNYXRoLnBvdygyLCBpZHgpO1xuICAgIH0pKTtcbiAgICAvLyBpbiB0ZXJtcyBvZiByYWRpdXMgdW5pdHNcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiY3VydmF0dXJlUmVzb2x1dGlvblwiLCA1KTtcbiAgICAvLyBpbiBkZWdyZWVzLCBhZmZlY3RzIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aWxlc1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ0aWxlTWFyZ2luXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJjbGVhclRpbGVzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIE9iamVjdC52YWx1ZXMoX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfdGlsZXNNZXRhLCBfdGhpcykpLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgbC5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgaWYgKGQub2JqKSB7XG4gICAgICAgICAgICBfdGhpcy5yZW1vdmUoZC5vYmopO1xuICAgICAgICAgICAgZW1wdHlPYmplY3QoZC5vYmopO1xuICAgICAgICAgICAgZGVsZXRlIGQub2JqO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldDIoX3RpbGVzTWV0YSwgX3RoaXMsIHt9KTtcbiAgICB9KTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQyKF9yYWRpdXMsIF90aGlzLCByYWRpdXMpO1xuICAgIF90aGlzLnRpbGVVcmwgPSB0aWxlVXJsO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldDIoX2lzTWVyY2F0b3IsIF90aGlzLCBtZXJjYXRvclByb2plY3Rpb24pO1xuICAgIF90aGlzLm1pbkxldmVsID0gbWluTGV2ZWw7XG4gICAgX3RoaXMubWF4TGV2ZWwgPSBtYXhMZXZlbDtcbiAgICBfdGhpcy5sZXZlbCA9IDA7XG5cbiAgICAvLyBBZGQgcHJvdGVjdGl2ZSBibGFjayBzcGhlcmUganVzdCBiZWxvdyBzdXJmYWNlIHRvIHByZXZlbnQgYW55IGRlcHRoIGJ1ZmZlciBhbm9tYWxpZXNcbiAgICBfdGhpcy5hZGQoX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MihfaW5uZXJCYWNrTGF5ZXIsIF90aGlzLCBuZXcgTWVzaChuZXcgU3BoZXJlR2VvbWV0cnkoX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfcmFkaXVzLCBfdGhpcykgKiAwLjk5LCAxODAsIDkwKSwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiAweDBcbiAgICB9KSkpKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9pbm5lckJhY2tMYXllciwgX3RoaXMpLnZpc2libGUgPSBmYWxzZTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9pbm5lckJhY2tMYXllciwgX3RoaXMpLm1hdGVyaWFsLnBvbHlnb25PZmZzZXQgPSB0cnVlO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2lubmVyQmFja0xheWVyLCBfdGhpcykubWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzID0gMztcbiAgICBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9pbm5lckJhY2tMYXllciwgX3RoaXMpLm1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAxO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoVGhyZWVTbGlwcHlNYXBHbG9iZSwgX0dyb3VwKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhUaHJlZVNsaXBweU1hcEdsb2JlLCBbe1xuICAgIGtleTogXCJ0aWxlVXJsXCIsXG4gICAgZ2V0OlxuICAgIC8vIFB1YmxpYyBhdHRyaWJ1dGVzXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3RpbGVVcmwsIHRoaXMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodGlsZVVybCkge1xuICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MihfdGlsZVVybCwgdGhpcywgdGlsZVVybCk7XG4gICAgICB0aGlzLnVwZGF0ZVBvdihfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9jYW1lcmEsIHRoaXMpKTsgLy8gdXBkYXRlIGN1cnJlbnQgdmlld1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2xldmVsLCB0aGlzKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGxldmVsKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGlmICghX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfdGlsZXNNZXRhLCB0aGlzKVtsZXZlbF0pIF9hc3NlcnRDbGFzc0JyYW5kKF9UaHJlZVNsaXBweU1hcEdsb2JlX2JyYW5kLCB0aGlzLCBfYnVpbGRNZXRhTGV2ZWwpLmNhbGwodGhpcywgbGV2ZWwpO1xuICAgICAgdmFyIHByZXZMZXZlbCA9IF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2xldmVsLCB0aGlzKTtcbiAgICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldDIoX2xldmVsLCB0aGlzLCBsZXZlbCk7XG4gICAgICBpZiAobGV2ZWwgPT09IHByZXZMZXZlbCB8fCBwcmV2TGV2ZWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBub3RoaW5nIGVsc2UgdG8gZG9cblxuICAgICAgLy8gQWN0aXZhdGUgYmFjayBsYXllciBmb3IgbGV2ZWxzID4gMCwgd2hlbiB0aGVyZSdzICFkZXB0aFdyaXRlIHRpbGVzXG4gICAgICBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9pbm5lckJhY2tMYXllciwgdGhpcykudmlzaWJsZSA9IGxldmVsID4gMDtcblxuICAgICAgLy8gQnJpbmcgbGF5ZXIgdG8gZnJvbnRcbiAgICAgIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3RpbGVzTWV0YSwgdGhpcylbbGV2ZWxdLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQub2JqICYmIChkLm9iai5tYXRlcmlhbC5kZXB0aFdyaXRlID0gdHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gcHVzaCBsb3dlciBsYXllcnMgdG8gYmFja2dyb3VuZFxuICAgICAgcHJldkxldmVsIDwgbGV2ZWwgJiYgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfdGlsZXNNZXRhLCB0aGlzKVtwcmV2TGV2ZWxdLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQub2JqICYmIChkLm9iai5tYXRlcmlhbC5kZXB0aFdyaXRlID0gZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlbW92ZSB1cHBlciBsYXllcnNcbiAgICAgIGlmIChwcmV2TGV2ZWwgPiBsZXZlbCkge1xuICAgICAgICBmb3IgKHZhciBsID0gbGV2ZWwgKyAxOyBsIDw9IHByZXZMZXZlbDsgbCsrKSB7XG4gICAgICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfdGlsZXNNZXRhLCB0aGlzKVtsXSAmJiBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF90aWxlc01ldGEsIHRoaXMpW2xdLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGlmIChkLm9iaikge1xuICAgICAgICAgICAgICBfdGhpczIucmVtb3ZlKGQub2JqKTtcbiAgICAgICAgICAgICAgZW1wdHlPYmplY3QoZC5vYmopO1xuICAgICAgICAgICAgICBkZWxldGUgZC5vYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9hc3NlcnRDbGFzc0JyYW5kKF9UaHJlZVNsaXBweU1hcEdsb2JlX2JyYW5kLCB0aGlzLCBfZmV0Y2hOZWVkZWRUaWxlcykuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWMgbWV0aG9kc1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVBvdlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVQb3YoY2FtZXJhKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGlmICghY2FtZXJhIHx8ICEoY2FtZXJhIGluc3RhbmNlb2YgQ2FtZXJhKSkgcmV0dXJuO1xuICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MihfY2FtZXJhLCB0aGlzLCBjYW1lcmEpO1xuICAgICAgdmFyIGZydXN0dW07XG4gICAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQyKF9pc0luVmlldywgdGhpcywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgaWYgKCFkLmh1bGxQbnRzKSB7XG4gICAgICAgICAgLy8gY2FjaGVkIGZvciBuZXh0IHRpbWUgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZVxuICAgICAgICAgIHZhciBsbmdMZW4gPSAzNjAgLyBNYXRoLnBvdygyLCBfdGhpczMubGV2ZWwpO1xuICAgICAgICAgIHZhciBsbmcgPSBkLmxuZyxcbiAgICAgICAgICAgIGxhdCA9IGQubGF0LFxuICAgICAgICAgICAgbGF0TGVuID0gZC5sYXRMZW47XG4gICAgICAgICAgdmFyIGxuZzAgPSBsbmcgLSBsbmdMZW4gLyAyO1xuICAgICAgICAgIHZhciBsbmcxID0gbG5nICsgbG5nTGVuIC8gMjtcbiAgICAgICAgICB2YXIgbGF0MCA9IGxhdCAtIGxhdExlbiAvIDI7XG4gICAgICAgICAgdmFyIGxhdDEgPSBsYXQgKyBsYXRMZW4gLyAyO1xuICAgICAgICAgIGQuaHVsbFBudHMgPSBbW2xhdCwgbG5nXSwgW2xhdDAsIGxuZzBdLCBbbGF0MSwgbG5nMF0sIFtsYXQwLCBsbmcxXSwgW2xhdDEsIGxuZzFdXS5tYXAoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgICB2YXIgX3JlZjMgPSBfc2xpY2VkVG9BcnJheShfcmVmMiwgMiksXG4gICAgICAgICAgICAgIGxhdCA9IF9yZWYzWzBdLFxuICAgICAgICAgICAgICBsbmcgPSBfcmVmM1sxXTtcbiAgICAgICAgICAgIHJldHVybiBwb2xhcjJDYXJ0ZXNpYW4obGF0LCBsbmcsIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3JhZGl1cywgX3RoaXMzKSk7XG4gICAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgICAgICAgdmFyIHggPSBfcmVmNC54LFxuICAgICAgICAgICAgICB5ID0gX3JlZjQueSxcbiAgICAgICAgICAgICAgeiA9IF9yZWY0Lno7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMoeCwgeSwgeik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmcnVzdHVtKSB7XG4gICAgICAgICAgZnJ1c3R1bSA9IG5ldyBGcnVzdHVtKCk7XG4gICAgICAgICAgY2FtZXJhLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgICAgIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgICAgIGZydXN0dW0uc2V0RnJvbVByb2plY3Rpb25NYXRyaXgobmV3IE1hdHJpeDQoKS5tdWx0aXBseU1hdHJpY2VzKGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQuaHVsbFBudHMuc29tZShmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgcmV0dXJuIGZydXN0dW0uY29udGFpbnNQb2ludChwb3MuY2xvbmUoKS5hcHBseU1hdHJpeDQoX3RoaXMzLm1hdHJpeFdvcmxkKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy50aWxlVXJsKSB7XG4gICAgICAgIHZhciBwb3YgPSBjYW1lcmEucG9zaXRpb24uY2xvbmUoKTtcbiAgICAgICAgdmFyIGRpc3RUb0dsb2JlQ2VudGVyID0gcG92LmRpc3RhbmNlVG8odGhpcy5nZXRXb3JsZFBvc2l0aW9uKG5ldyBWZWN0b3IzKCkpKTtcbiAgICAgICAgdmFyIGNhbWVyYURpc3RhbmNlID0gKGRpc3RUb0dsb2JlQ2VudGVyIC0gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfcmFkaXVzLCB0aGlzKSkgLyBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9yYWRpdXMsIHRoaXMpOyAvLyBpbiB1bml0cyBvZiBnbG9iZSByYWRpdXNcblxuICAgICAgICB2YXIgaWR4ID0gdGhpcy50aHJlc2hvbGRzLmZpbmRJbmRleChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0ICYmIHQgPD0gY2FtZXJhRGlzdGFuY2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxldmVsID0gTWF0aC5taW4odGhpcy5tYXhMZXZlbCwgTWF0aC5tYXgodGhpcy5taW5MZXZlbCwgaWR4IDwgMCA/IHRoaXMudGhyZXNob2xkcy5sZW5ndGggOiBpZHgpKTtcbiAgICAgICAgX2Fzc2VydENsYXNzQnJhbmQoX1RocmVlU2xpcHB5TWFwR2xvYmVfYnJhbmQsIHRoaXMsIF9mZXRjaE5lZWRlZFRpbGVzKS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xufShHcm91cCk7XG5mdW5jdGlvbiBfYnVpbGRNZXRhTGV2ZWwobGV2ZWwpIHtcbiAgdmFyIF90aGlzNCA9IHRoaXM7XG4gIGlmIChsZXZlbCA+IE1BWF9MRVZFTF9UT19CVUlMRF9MT09LVVBfT0NUUkVFKSB7XG4gICAgLy8gR2VuZXJhdGUgbWV0YSBkeW5hbWljYWxseVxuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3RpbGVzTWV0YSwgdGhpcylbbGV2ZWxdID0gW107XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gR2VuZXJhdGUgZGlzdGFuY2UgbG9va3VwIG9jdHJlZVxuICB2YXIgbGV2ZWxNZXRhID0gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfdGlsZXNNZXRhLCB0aGlzKVtsZXZlbF0gPSBnZW5UaWxlc0Nvb3JkcyhsZXZlbCwgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfaXNNZXJjYXRvciwgdGhpcykpO1xuICBsZXZlbE1ldGEuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLmNlbnRyb2lkID0gcG9sYXIyQ2FydGVzaWFuKGQubGF0LCBkLmxuZywgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfcmFkaXVzLCBfdGhpczQpKTtcbiAgfSk7XG4gIGxldmVsTWV0YS5vY3RyZWUgPSBvY3RyZWUoKS54KGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuY2VudHJvaWQueDtcbiAgfSkueShmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLmNlbnRyb2lkLnk7XG4gIH0pLnooZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5jZW50cm9pZC56O1xuICB9KS5hZGRBbGwobGV2ZWxNZXRhKTtcbn1cbmZ1bmN0aW9uIF9mZXRjaE5lZWRlZFRpbGVzKCkge1xuICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgaWYgKCF0aGlzLnRpbGVVcmwgfHwgdGhpcy5sZXZlbCA9PT0gdW5kZWZpbmVkIHx8ICFfY2xhc3NQcml2YXRlRmllbGRHZXQyKF90aWxlc01ldGEsIHRoaXMpLmhhc093blByb3BlcnR5KHRoaXMubGV2ZWwpKSByZXR1cm47XG5cbiAgLy8gU2FmZXR5IGlmIGNhbid0IGNoZWNrIGluIHZpZXcgdGlsZXMgZm9yIGhpZ2hlciBsZXZlbHNcbiAgaWYgKCFfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9pc0luVmlldywgdGhpcykgJiYgdGhpcy5sZXZlbCA+IE1BWF9MRVZFTF9UT19SRU5ERVJfQUxMX1RJTEVTKSByZXR1cm47XG4gIHZhciB0aWxlcyA9IF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3RpbGVzTWV0YSwgdGhpcylbdGhpcy5sZXZlbF07XG4gIGlmIChfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9jYW1lcmEsIHRoaXMpKSB7XG4gICAgLy8gUHJlLXNlbGVjdCB0aWxlcyBjbG9zZSB0byB0aGUgY2FtZXJhXG4gICAgdmFyIHBvdlBvcyA9IHRoaXMud29ybGRUb0xvY2FsKF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2NhbWVyYSwgdGhpcykucG9zaXRpb24uY2xvbmUoKSk7XG4gICAgaWYgKHRpbGVzLm9jdHJlZSkge1xuICAgICAgdmFyIF90aWxlcyRvY3RyZWU7XG4gICAgICAvLyBPY3RyZWUgYmFzZWQgb24gM2QgcG9zaXRpb25zIGlzIG1vcmUgYWNjdXJhdGVcbiAgICAgIHZhciBfcG92UG9zID0gdGhpcy53b3JsZFRvTG9jYWwoX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfY2FtZXJhLCB0aGlzKS5wb3NpdGlvbi5jbG9uZSgpKTtcbiAgICAgIHZhciBzZWFyY2hSYWRpdXMgPSAoX3BvdlBvcy5sZW5ndGgoKSAtIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3JhZGl1cywgdGhpcykpICogVElMRV9TRUFSQ0hfUkFESVVTX0NBTUVSQV9ESVNUQU5DRTtcbiAgICAgIHRpbGVzID0gKF90aWxlcyRvY3RyZWUgPSB0aWxlcy5vY3RyZWUpLmZpbmRBbGxXaXRoaW5SYWRpdXMuYXBwbHkoX3RpbGVzJG9jdHJlZSwgX3RvQ29uc3VtYWJsZUFycmF5KF9wb3ZQb3MpLmNvbmNhdChbc2VhcmNoUmFkaXVzXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aWxlcyBwb3B1bGF0ZWQgZHluYW1pY2FsbHlcbiAgICAgIHZhciBwb3ZDb29yZHMgPSBjYXJ0ZXNpYW4yUG9sYXIocG92UG9zKTtcbiAgICAgIHZhciBzZWFyY2hSYWRpdXNMYXQgPSAocG92Q29vcmRzLnIgLyBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9yYWRpdXMsIHRoaXMpIC0gMSkgKiBUSUxFX1NFQVJDSF9SQURJVVNfU1VSRkFDRV9ESVNUQU5DRTtcbiAgICAgIHZhciBzZWFyY2hSYWRpdXNMbmcgPSBzZWFyY2hSYWRpdXNMYXQgLyBNYXRoLmNvcyhkZWcyUmFkKHBvdkNvb3Jkcy5sYXQpKTsgLy8gRGlzdGFuY2VzIGluIGxvbmdpdHVkZSBkZWdyZWVzIHNocmluayB0b3dhcmRzIHRoZSBwb2xlc1xuICAgICAgdmFyIGxuZ1JhbmdlID0gW3BvdkNvb3Jkcy5sbmcgLSBzZWFyY2hSYWRpdXNMbmcsIHBvdkNvb3Jkcy5sbmcgKyBzZWFyY2hSYWRpdXNMbmddO1xuICAgICAgdmFyIGxhdFJhbmdlID0gW3BvdkNvb3Jkcy5sYXQgKyBzZWFyY2hSYWRpdXNMYXQsIHBvdkNvb3Jkcy5sYXQgLSBzZWFyY2hSYWRpdXNMYXRdO1xuICAgICAgdmFyIF9maW5kVGlsZVhZID0gZmluZFRpbGVYWSh0aGlzLmxldmVsLCBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9pc01lcmNhdG9yLCB0aGlzKSwgbG5nUmFuZ2VbMF0sIGxhdFJhbmdlWzBdKSxcbiAgICAgICAgX2ZpbmRUaWxlWFkyID0gX3NsaWNlZFRvQXJyYXkoX2ZpbmRUaWxlWFksIDIpLFxuICAgICAgICB4MCA9IF9maW5kVGlsZVhZMlswXSxcbiAgICAgICAgeTAgPSBfZmluZFRpbGVYWTJbMV07XG4gICAgICB2YXIgX2ZpbmRUaWxlWFkzID0gZmluZFRpbGVYWSh0aGlzLmxldmVsLCBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9pc01lcmNhdG9yLCB0aGlzKSwgbG5nUmFuZ2VbMV0sIGxhdFJhbmdlWzFdKSxcbiAgICAgICAgX2ZpbmRUaWxlWFk0ID0gX3NsaWNlZFRvQXJyYXkoX2ZpbmRUaWxlWFkzLCAyKSxcbiAgICAgICAgeDEgPSBfZmluZFRpbGVYWTRbMF0sXG4gICAgICAgIHkxID0gX2ZpbmRUaWxlWFk0WzFdO1xuICAgICAgIXRpbGVzLnJlY29yZCAmJiAodGlsZXMucmVjb3JkID0ge30pOyAvLyBJbmRleCBnZW4gdGlsZXMgYnkgWFlcbiAgICAgIHZhciByID0gdGlsZXMucmVjb3JkO1xuICAgICAgaWYgKCFyLmhhc093blByb3BlcnR5KFwiXCIuY29uY2F0KE1hdGgucm91bmQoKHgwICsgeDEpIC8gMiksIFwiX1wiKS5jb25jYXQoTWF0aC5yb3VuZCgoeTAgKyB5MSkgLyAyKSkpKSB7XG4gICAgICAgIC8vIGdlbiBhbGwgZm91bmQgdGlsZXMgaWYgbWlkZGxlIG9uZSBpcyBub3QgaW4gcmVjb3JkXG4gICAgICAgIHRpbGVzID0gZ2VuVGlsZXNDb29yZHModGhpcy5sZXZlbCwgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfaXNNZXJjYXRvciwgdGhpcyksIHgwLCB5MCwgeDEsIHkxKS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICB2YXIgayA9IFwiXCIuY29uY2F0KGQueCwgXCJfXCIpLmNvbmNhdChkLnkpO1xuICAgICAgICAgIGlmIChyLmhhc093blByb3BlcnR5KGspKSByZXR1cm4gcltrXTtcbiAgICAgICAgICByW2tdID0gZDtcbiAgICAgICAgICB0aWxlcy5wdXNoKGQpO1xuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdlbiBvbmx5IHRob3NlIG1pc3NpbmcsIG9uZSBieSBvbmVcbiAgICAgICAgdmFyIHNlbFRpbGVzID0gW107XG4gICAgICAgIGZvciAodmFyIHggPSB4MDsgeCA8PSB4MTsgeCsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgeSA9IHkwOyB5IDw9IHkxOyB5KyspIHtcbiAgICAgICAgICAgIHZhciBrID0gXCJcIi5jb25jYXQoeCwgXCJfXCIpLmNvbmNhdCh5KTtcbiAgICAgICAgICAgIGlmICghci5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICByW2tdID0gZ2VuVGlsZXNDb29yZHModGhpcy5sZXZlbCwgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfaXNNZXJjYXRvciwgdGhpcyksIHgsIHksIHgsIHkpWzBdO1xuICAgICAgICAgICAgICB0aWxlcy5wdXNoKHJba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsVGlsZXMucHVzaChyW2tdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGlsZXMgPSBzZWxUaWxlcztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICBjb25zb2xlLmxvZyh7XG4gICAgbGV2ZWw6IHRoaXMubGV2ZWwsXG4gICAgdG90YWxPYmpzOiB0aGlzLmNoaWxkcmVuLmxlbmd0aCxcbiAgICB0aWxlc0ZvdW5kOiB0aWxlcy5sZW5ndGgsXG4gICAgdGlsZXNJblZpZXc6IHRpbGVzLmZpbHRlcih0aGlzLiNpc0luVmlldyB8fCAoKCkgPT4gdHJ1ZSkpLmxlbmd0aCxcbiAgICBsZXZlbFRpbGVzOiB0aGlzLiN0aWxlc01ldGFbdGhpcy5sZXZlbF0ubGVuZ3RoLFxuICAgIGZldGNoZWQ6IHRoaXMuI3RpbGVzTWV0YVt0aGlzLmxldmVsXS5maWx0ZXIoZCA9PiBkLm9iaikubGVuZ3RoLFxuICAgIGxvYWRpbmc6IHRoaXMuI3RpbGVzTWV0YVt0aGlzLmxldmVsXS5maWx0ZXIoZCA9PiBkLmxvYWRpbmcpLmxlbmd0aCxcbiAgfSk7XG4gICovXG5cbiAgdGlsZXMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuICFkLm9iajtcbiAgfSkuZmlsdGVyKF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2lzSW5WaWV3LCB0aGlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICB2YXIgeCA9IGQueCxcbiAgICAgIHkgPSBkLnksXG4gICAgICBsbmcgPSBkLmxuZyxcbiAgICAgIGxhdCA9IGQubGF0LFxuICAgICAgbGF0TGVuID0gZC5sYXRMZW47XG4gICAgdmFyIGxuZ0xlbiA9IDM2MCAvIE1hdGgucG93KDIsIF90aGlzNS5sZXZlbCk7XG4gICAgaWYgKCFkLm9iaikge1xuICAgICAgdmFyIHdpZHRoID0gbG5nTGVuICogKDEgLSBfdGhpczUudGlsZU1hcmdpbik7XG4gICAgICB2YXIgaGVpZ2h0ID0gbGF0TGVuICogKDEgLSBfdGhpczUudGlsZU1hcmdpbik7XG4gICAgICB2YXIgcm90TG5nID0gZGVnMlJhZChsbmcpO1xuICAgICAgdmFyIHJvdExhdCA9IGRlZzJSYWQoLWxhdCk7XG4gICAgICB2YXIgdGlsZSA9IG5ldyBNZXNoKG5ldyBTcGhlcmVHZW9tZXRyeShfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9yYWRpdXMsIF90aGlzNSksIE1hdGguY2VpbCh3aWR0aCAvIF90aGlzNS5jdXJ2YXR1cmVSZXNvbHV0aW9uKSwgTWF0aC5jZWlsKGhlaWdodCAvIF90aGlzNS5jdXJ2YXR1cmVSZXNvbHV0aW9uKSwgZGVnMlJhZCg5MCAtIHdpZHRoIC8gMikgKyByb3RMbmcsIGRlZzJSYWQod2lkdGgpLCBkZWcyUmFkKDkwIC0gaGVpZ2h0IC8gMikgKyByb3RMYXQsIGRlZzJSYWQoaGVpZ2h0KSksIG5ldyBNZXNoTGFtYmVydE1hdGVyaWFsKCkpO1xuICAgICAgaWYgKF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2lzTWVyY2F0b3IsIF90aGlzNSkpIHtcbiAgICAgICAgdmFyIF9tYXAgPSBbbGF0ICsgbGF0TGVuIC8gMiwgbGF0IC0gbGF0TGVuIC8gMl0ubWFwKGZ1bmN0aW9uIChsYXQpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjUgLSBsYXQgLyAxODA7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgX21hcDIgPSBfc2xpY2VkVG9BcnJheShfbWFwLCAyKSxcbiAgICAgICAgICBfeSA9IF9tYXAyWzBdLFxuICAgICAgICAgIF95MiA9IF9tYXAyWzFdO1xuICAgICAgICBjb252ZXJ0TWVyY2F0b3JVVih0aWxlLmdlb21ldHJ5LmF0dHJpYnV0ZXMudXYsIF95LCBfeTIpO1xuICAgICAgfVxuICAgICAgZC5vYmogPSB0aWxlO1xuICAgIH1cbiAgICBpZiAoIWQubG9hZGluZykge1xuICAgICAgZC5sb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgLy8gRmV0Y2ggdGlsZSBpbWFnZVxuICAgICAgbmV3IFRleHR1cmVMb2FkZXIoKS5sb2FkKF90aGlzNS50aWxlVXJsKHgsIHksIF90aGlzNS5sZXZlbCksIGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG4gICAgICAgIHZhciB0aWxlID0gZC5vYmo7XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgdGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U7XG4gICAgICAgICAgdGlsZS5tYXRlcmlhbC5tYXAgPSB0ZXh0dXJlO1xuICAgICAgICAgIHRpbGUubWF0ZXJpYWwuY29sb3IgPSBudWxsO1xuICAgICAgICAgIHRpbGUubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIF90aGlzNS5hZGQodGlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZC5sb2FkaW5nID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgeyBUaHJlZVNsaXBweU1hcEdsb2JlIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJHcm91cCIsIk1lc2giLCJTcGhlcmVHZW9tZXRyeSIsIk1lc2hCYXNpY01hdGVyaWFsIiwiQ2FtZXJhIiwiVmVjdG9yMyIsIkZydXN0dW0iLCJNYXRyaXg0IiwiTWVzaExhbWJlcnRNYXRlcmlhbCIsIlRleHR1cmVMb2FkZXIiLCJTUkdCQ29sb3JTcGFjZSIsIm9jdHJlZSIsInNjYWxlTGluZWFyIiwiZ2VvTWVyY2F0b3JSYXciLCJfYXJyYXlMaWtlVG9BcnJheSIsInIiLCJhIiwibGVuZ3RoIiwiZSIsIm4iLCJBcnJheSIsIl9hcnJheVdpdGhIb2xlcyIsImlzQXJyYXkiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfYXNzZXJ0Q2xhc3NCcmFuZCIsInQiLCJoYXMiLCJhcmd1bWVudHMiLCJUeXBlRXJyb3IiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwidW5kZWZpbmVkIiwiUmVmZXJlbmNlRXJyb3IiLCJfY2FsbFN1cGVyIiwibyIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJjb25zdHJ1Y3RvciIsImFwcGx5IiwiX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24iLCJfY2xhc3NDYWxsQ2hlY2siLCJfY2xhc3NQcml2YXRlRmllbGRHZXQyIiwicyIsImdldCIsIl9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjIiwic2V0IiwiX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MiIsIl9jbGFzc1ByaXZhdGVNZXRob2RJbml0U3BlYyIsImFkZCIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvdHlwZSIsIl9kZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsImJpbmQiLCJfX3Byb3RvX18iLCJfaW5oZXJpdHMiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJCb29sZWFuIiwidmFsdWVPZiIsImNhbGwiLCJfaXRlcmFibGVUb0FycmF5IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJmcm9tIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwibCIsImkiLCJ1IiwiZiIsIm5leHQiLCJkb25lIiwicHVzaCIsInJldHVybiIsIl9ub25JdGVyYWJsZVJlc3QiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJfc2xpY2VkVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl90b0NvbnN1bWFibGVBcnJheSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJ0ZXN0IiwiX21hdGVyaWFsRGlzcG9zZSIsIm1hdGVyaWFsRGlzcG9zZSIsIm1hdGVyaWFsIiwiZm9yRWFjaCIsIm1hcCIsImRpc3Bvc2UiLCJfZGVhbGxvY2F0ZSIsImRlYWxsb2NhdGUiLCJvYmoiLCJnZW9tZXRyeSIsInRleHR1cmUiLCJjaGlsZHJlbiIsImVtcHR5T2JqZWN0IiwiY2hpbGRPYmoiLCJyZW1vdmUiLCJwb2xhcjJDYXJ0ZXNpYW4iLCJsYXQiLCJsbmciLCJwaGkiLCJNYXRoIiwiUEkiLCJ0aGV0YSIsIngiLCJzaW4iLCJjb3MiLCJ5IiwieiIsImNhcnRlc2lhbjJQb2xhciIsIl9yZWYiLCJzcXJ0IiwiYWNvcyIsImF0YW4yIiwiZGVnMlJhZCIsImRlZyIsInlNZXJjYXRvclNjYWxlIiwieU1lcmNhdG9yU2NhbGVDbGFtcGVkIiwibWF4IiwibWluIiwieU1lcmNhdG9yU2NhbGVJbnZlcnQiLCJpbnZlcnQiLCJjb252ZXJ0TWVyY2F0b3JVViIsInV2cyIsInkwIiwieTEiLCJvZmZzZXRTY2FsZSIsImRvbWFpbiIsInJhbmdlIiwiY2xhbXAiLCJyZXZPZmZzZXRTY2FsZSIsInNjYWxlIiwidiIsImFyciIsImFycmF5IiwibGVuIiwibmVlZHNVcGRhdGUiLCJmaW5kVGlsZVhZIiwibGV2ZWwiLCJpc01lcmNhdG9yIiwiZ3JpZFNpemUiLCJwb3ciLCJmbG9vciIsInJlbFkiLCJnZW5UaWxlc0Nvb3JkcyIsIngwIiwiX3gxIiwiX3kxIiwidGlsZXMiLCJ0aWxlTG5nTGVuIiwicmVnVGlsZUxhdExlbiIsIngxIiwibWF4WCIsIm1heFkiLCJyZXByb1kiLCJ0aWxlTGF0TGVuIiwicmVwcm9ZRW5kIiwibGF0TGVuIiwiTUFYX0xFVkVMX1RPX1JFTkRFUl9BTExfVElMRVMiLCJNQVhfTEVWRUxfVE9fQlVJTERfTE9PS1VQX09DVFJFRSIsIlRJTEVfU0VBUkNIX1JBRElVU19DQU1FUkFfRElTVEFOQ0UiLCJUSUxFX1NFQVJDSF9SQURJVVNfU1VSRkFDRV9ESVNUQU5DRSIsIl9yYWRpdXMiLCJXZWFrTWFwIiwiX2lzTWVyY2F0b3IiLCJfdGlsZVVybCIsIl9sZXZlbCIsIl90aWxlc01ldGEiLCJfaXNJblZpZXciLCJfY2FtZXJhIiwiX2lubmVyQmFja0xheWVyIiwiX1RocmVlU2xpcHB5TWFwR2xvYmVfYnJhbmQiLCJXZWFrU2V0IiwiVGhyZWVTbGlwcHlNYXBHbG9iZSIsIl9Hcm91cCIsInJhZGl1cyIsIl90aGlzIiwidGlsZVVybCIsIl9yZWYkbWluTGV2ZWwiLCJtaW5MZXZlbCIsIl9yZWYkbWF4TGV2ZWwiLCJtYXhMZXZlbCIsIl9yZWYkbWVyY2F0b3JQcm9qZWN0aSIsIm1lcmNhdG9yUHJvamVjdGlvbiIsIl8iLCJpZHgiLCJ2YWx1ZXMiLCJkIiwiY29sb3IiLCJ2aXNpYmxlIiwicG9seWdvbk9mZnNldCIsInBvbHlnb25PZmZzZXRVbml0cyIsInBvbHlnb25PZmZzZXRGYWN0b3IiLCJ1cGRhdGVQb3YiLCJfdGhpczIiLCJfYnVpbGRNZXRhTGV2ZWwiLCJwcmV2TGV2ZWwiLCJkZXB0aFdyaXRlIiwiX2ZldGNoTmVlZGVkVGlsZXMiLCJjYW1lcmEiLCJfdGhpczMiLCJmcnVzdHVtIiwiaHVsbFBudHMiLCJsbmdMZW4iLCJsbmcwIiwibG5nMSIsImxhdDAiLCJsYXQxIiwiX3JlZjIiLCJfcmVmMyIsIl9yZWY0IiwidXBkYXRlTWF0cml4IiwidXBkYXRlTWF0cml4V29ybGQiLCJzZXRGcm9tUHJvamVjdGlvbk1hdHJpeCIsIm11bHRpcGx5TWF0cmljZXMiLCJwcm9qZWN0aW9uTWF0cml4IiwibWF0cml4V29ybGRJbnZlcnNlIiwic29tZSIsInBvcyIsImNvbnRhaW5zUG9pbnQiLCJjbG9uZSIsImFwcGx5TWF0cml4NCIsIm1hdHJpeFdvcmxkIiwicG92IiwicG9zaXRpb24iLCJkaXN0VG9HbG9iZUNlbnRlciIsImRpc3RhbmNlVG8iLCJnZXRXb3JsZFBvc2l0aW9uIiwiY2FtZXJhRGlzdGFuY2UiLCJ0aHJlc2hvbGRzIiwiZmluZEluZGV4IiwiX3RoaXM0IiwibGV2ZWxNZXRhIiwiY2VudHJvaWQiLCJhZGRBbGwiLCJfdGhpczUiLCJoYXNPd25Qcm9wZXJ0eSIsInBvdlBvcyIsIndvcmxkVG9Mb2NhbCIsIl90aWxlcyRvY3RyZWUiLCJfcG92UG9zIiwic2VhcmNoUmFkaXVzIiwiZmluZEFsbFdpdGhpblJhZGl1cyIsImNvbmNhdCIsInBvdkNvb3JkcyIsInNlYXJjaFJhZGl1c0xhdCIsInNlYXJjaFJhZGl1c0xuZyIsImxuZ1JhbmdlIiwibGF0UmFuZ2UiLCJfZmluZFRpbGVYWSIsIl9maW5kVGlsZVhZMiIsIl9maW5kVGlsZVhZMyIsIl9maW5kVGlsZVhZNCIsInJlY29yZCIsInJvdW5kIiwiayIsInNlbFRpbGVzIiwiZmlsdGVyIiwid2lkdGgiLCJ0aWxlTWFyZ2luIiwiaGVpZ2h0Iiwicm90TG5nIiwicm90TGF0IiwidGlsZSIsImNlaWwiLCJjdXJ2YXR1cmVSZXNvbHV0aW9uIiwiX21hcCIsIl9tYXAyIiwiX3kiLCJfeTIiLCJhdHRyaWJ1dGVzIiwidXYiLCJsb2FkaW5nIiwibG9hZCIsImNvbG9yU3BhY2UiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-slippy-map-globe/dist/three-slippy-map-globe.mjs\n");

/***/ })

};
;