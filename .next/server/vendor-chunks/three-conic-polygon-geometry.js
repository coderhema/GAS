"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-conic-polygon-geometry";
exports.ids = ["vendor-chunks/three-conic-polygon-geometry"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-conic-polygon-geometry/dist/three-conic-polygon-geometry.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/three-conic-polygon-geometry/dist/three-conic-polygon-geometry.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ConicPolygonGeometry)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/merge.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/mean.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/extent.js\");\n/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! earcut */ \"(ssr)/./node_modules/earcut/src/earcut.js\");\n/* harmony import */ var delaunator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! delaunator */ \"(ssr)/./node_modules/delaunator/index.js\");\n/* harmony import */ var _turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @turf/boolean-point-in-polygon */ \"(ssr)/./node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/bounds.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/distance.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/interpolate.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/contains.js\");\n/* harmony import */ var d3_geo_voronoi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-geo-voronoi */ \"(ssr)/./node_modules/d3-geo-voronoi/src/voronoi.js\");\n/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale */ \"(ssr)/./node_modules/d3-scale/src/linear.js\");\n\n\n\n\n\n\n\n\nfunction _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n    return n;\n}\nfunction _arrayWithHoles(r) {\n    if (Array.isArray(r)) return r;\n}\nfunction _arrayWithoutHoles(r) {\n    if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _assertThisInitialized(e) {\n    if (undefined === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return e;\n}\nfunction _callSuper(t, o, e) {\n    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _createClass(e, r, t) {\n    return Object.defineProperty(e, \"prototype\", {\n        writable: false\n    }), e;\n}\nfunction _getPrototypeOf(t) {\n    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {\n        return t.__proto__ || Object.getPrototypeOf(t);\n    }, _getPrototypeOf(t);\n}\nfunction _inherits(t, e) {\n    if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n    t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n            value: t,\n            writable: true,\n            configurable: true\n        }\n    }), Object.defineProperty(t, \"prototype\", {\n        writable: false\n    }), e && _setPrototypeOf(t, e);\n}\nfunction _isNativeReflectConstruct() {\n    try {\n        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (t) {}\n    return (_isNativeReflectConstruct = function() {\n        return !!t;\n    })();\n}\nfunction _iterableToArray(r) {\n    if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = true, o = false;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) ;\n            else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = true, n = r;\n        } finally{\n            try {\n                if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _possibleConstructorReturn(t, e) {\n    if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n    if (undefined !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n    return _assertThisInitialized(t);\n}\nfunction _setPrototypeOf(t, e) {\n    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {\n        return t.__proto__ = e, t;\n    }, _setPrototypeOf(t, e);\n}\nfunction _slicedToArray(r, e) {\n    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _toConsumableArray(r) {\n    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _unsupportedIterableToArray(r, a) {\n    if (r) {\n        if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n        var t = ({}).toString.call(r).slice(8, -1);\n        return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : undefined;\n    }\n}\nfunction geoPolygonTriangulate(polygon) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$resolution = _ref.resolution, resolution = _ref$resolution === undefined ? Infinity : _ref$resolution;\n    var contour = interpolateContourPoints(polygon, resolution);\n    var edgePoints = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(contour);\n    var innerPoints = getInnerGeoPoints(polygon, resolution);\n    var points = [].concat(_toConsumableArray(edgePoints), _toConsumableArray(innerPoints));\n    var boundariesGeojson = {\n        type: \"Polygon\",\n        coordinates: polygon\n    };\n    var _geoBounds = (0,d3_geo__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(boundariesGeojson), _geoBounds2 = _slicedToArray(_geoBounds, 2), _geoBounds2$ = _slicedToArray(_geoBounds2[0], 2), minLng = _geoBounds2$[0], minLat = _geoBounds2$[1], _geoBounds2$2 = _slicedToArray(_geoBounds2[1], 2), maxLng = _geoBounds2$2[0], maxLat = _geoBounds2$2[1];\n    var crossesPoleOrAntimeridian = minLng > maxLng // crosses antimeridian\n     || maxLat >= 89 // crosses north pole\n     || minLat <= -89; // crosses south pole\n    var indices = [];\n    if (crossesPoleOrAntimeridian) {\n        // Use d3-geo-voronoi. Slowest, but most accurate for polygons that cross poles or anti-meridian\n        var vt = (0,d3_geo_voronoi__WEBPACK_IMPORTED_MODULE_3__.geoVoronoi)(points).triangles(); // geoDelaunay generates more triangles than needed\n        var pntMap = new Map(points.map(function(_ref2, idx) {\n            var _ref3 = _slicedToArray(_ref2, 2), lng = _ref3[0], lat = _ref3[1];\n            return [\n                \"\".concat(lng, \"-\").concat(lat),\n                idx\n            ];\n        }));\n        vt.features.forEach(function(f) {\n            var _indices;\n            var triangle = f.geometry.coordinates[0].slice(0, 3).reverse(); // reverse wound to match earcut\n            var inds = [];\n            triangle.forEach(function(_ref4) {\n                var _ref5 = _slicedToArray(_ref4, 2), lng = _ref5[0], lat = _ref5[1];\n                var k = \"\".concat(lng, \"-\").concat(lat);\n                pntMap.has(k) && inds.push(pntMap.get(k));\n            });\n            if (inds.length !== 3) return; // triangle malfunction\n            // exclude edge triangles outside polygon perimeter or through holes\n            if (inds.some(function(ind) {\n                return ind < edgePoints.length;\n            })) {\n                var triangleCentroid = f.properties.circumcenter;\n                if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return;\n            }\n            (_indices = indices).push.apply(_indices, inds);\n        });\n    } else if (!innerPoints.length) {\n        // earcut triangulation slightly more performing if it's only using the polygon perimeter\n        var _earcutFlatten = (0,earcut__WEBPACK_IMPORTED_MODULE_0__.flatten)(contour), vertices = _earcutFlatten.vertices, _earcutFlatten$holes = _earcutFlatten.holes, holes = _earcutFlatten$holes === undefined ? [] : _earcutFlatten$holes;\n        indices = (0,earcut__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(vertices, holes, 2);\n    } else {\n        // use delaunator\n        var delaunay = delaunator__WEBPACK_IMPORTED_MODULE_4__[\"default\"].from(points);\n        var _loop = function _loop(i) {\n            var _indices2;\n            var inds = [\n                2,\n                1,\n                0\n            ].map(function(idx) {\n                return delaunay.triangles[i + idx];\n            }); // reverse wound to have same orientation as earcut\n            var triangle = inds.map(function(indice) {\n                return points[indice];\n            });\n            // exclude edge triangles outside polygon perimeter or through holes\n            if (inds.some(function(ind) {\n                return ind < edgePoints.length;\n            })) {\n                var triangleCentroid = [\n                    0,\n                    1\n                ].map(function(coordIdx) {\n                    return (0,d3_array__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(triangle, function(p) {\n                        return p[coordIdx];\n                    });\n                });\n                if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return 1; // continue\n            }\n            (_indices2 = indices).push.apply(_indices2, _toConsumableArray(inds));\n        };\n        for(var i = 0, len = delaunay.triangles.length; i < len; i += 3){\n            if (_loop(i)) continue;\n        }\n    }\n    // calc uvs\n    var lngUvScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_6__[\"default\"])((0,d3_array__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(points, function(d) {\n        return d[0];\n    }), [\n        0,\n        1\n    ]);\n    var latUvScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_6__[\"default\"])((0,d3_array__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(points, function(d) {\n        return d[1];\n    }), [\n        0,\n        1\n    ]);\n    var uvs = points.map(function(_ref6) {\n        var _ref7 = _slicedToArray(_ref6, 2), lng = _ref7[0], lat = _ref7[1];\n        return [\n            lngUvScale(lng),\n            latUvScale(lat)\n        ];\n    });\n    var triangles = {\n        points: points,\n        indices: indices,\n        uvs: uvs\n    };\n    return {\n        contour: contour,\n        triangles: triangles\n    };\n}\nfunction interpolateContourPoints(polygon, maxDistance) {\n    // add interpolated points for segments that are further apart than the max distance\n    return polygon.map(function(coords) {\n        var pnts = [];\n        var prevPnt;\n        coords.forEach(function(pnt) {\n            if (prevPnt) {\n                var dist = (0,d3_geo__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(pnt, prevPnt) * 180 / Math.PI;\n                if (dist > maxDistance) {\n                    var interpol = (0,d3_geo__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(prevPnt, pnt);\n                    var tStep = 1 / Math.ceil(dist / maxDistance);\n                    var t = tStep;\n                    while(t < 1){\n                        pnts.push(interpol(t));\n                        t += tStep;\n                    }\n                }\n            }\n            pnts.push(prevPnt = pnt);\n        });\n        return pnts;\n    });\n}\nfunction getInnerGeoPoints(polygon, maxDistance) {\n    var boundariesGeojson = {\n        type: \"Polygon\",\n        coordinates: polygon\n    };\n    var _geoBounds3 = (0,d3_geo__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(boundariesGeojson), _geoBounds4 = _slicedToArray(_geoBounds3, 2), _geoBounds4$ = _slicedToArray(_geoBounds4[0], 2), minLng = _geoBounds4$[0], minLat = _geoBounds4$[1], _geoBounds4$2 = _slicedToArray(_geoBounds4[1], 2), maxLng = _geoBounds4$2[0], maxLat = _geoBounds4$2[1];\n    // polygon smaller than maxDistance -> no inner points\n    if (Math.min(Math.abs(maxLng - minLng), Math.abs(maxLat - minLat)) < maxDistance) return [];\n    var crossesPoleOrAntimeridian = minLng > maxLng || maxLat >= 89 || minLat <= -89;\n    return getGeoSpiralGrid(maxDistance, {\n        minLng: minLng,\n        maxLng: maxLng,\n        minLat: minLat,\n        maxLat: maxLat\n    }).filter(function(pnt) {\n        return pointInside(pnt, boundariesGeojson, crossesPoleOrAntimeridian);\n    });\n}\nfunction getGeoSpiralGrid(distanceBetweenPoints) {\n    var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, minLng = _ref8.minLng, maxLng = _ref8.maxLng, minLat = _ref8.minLat, maxLat = _ref8.maxLat;\n    var numPoints = Math.round(Math.pow(360 / distanceBetweenPoints, 2) / Math.PI);\n    // https://observablehq.com/@mbostock/spherical-fibonacci-lattice\n    var phi = (1 + Math.sqrt(5)) / 2; // golden ratio\n    var getPntLng = function getPntLng(idx) {\n        return idx / phi * 360 % 360 - 180;\n    };\n    var getPntLat = function getPntLat(idx) {\n        return Math.acos(2 * idx / numPoints - 1) / Math.PI * 180 - 90;\n    };\n    var getPntIdx = function getPntIdx(lat) {\n        return numPoints * (Math.cos((lat + 90) * Math.PI / 180) + 1) / 2;\n    };\n    var pntIdxRange = [\n        maxLat !== undefined ? Math.ceil(getPntIdx(maxLat)) : 0,\n        minLat !== undefined ? Math.floor(getPntIdx(minLat)) : numPoints - 1\n    ];\n    var isLngInRange = minLng === undefined && maxLng === undefined ? function() {\n        return true;\n    } : minLng === undefined ? function(lng) {\n        return lng <= maxLng;\n    } : maxLng === undefined ? function(lng) {\n        return lng >= minLng;\n    } : maxLng >= minLng ? function(lng) {\n        return lng >= minLng && lng <= maxLng;\n    } : function(lng) {\n        return lng >= minLng || lng <= maxLng;\n    }; // for ranges that cross the anti-meridian\n    var pnts = [];\n    for(var i = pntIdxRange[0]; i <= pntIdxRange[1]; i++){\n        var lng = getPntLng(i);\n        isLngInRange(lng) && pnts.push([\n            lng,\n            getPntLat(i)\n        ]);\n    }\n    return pnts;\n}\nfunction pointInside(pnt, polygon) {\n    var crossesPoleOrAntimeridian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    // turf method is more performing but malfunctions if polygon includes a pole (lat = 90 | -90) or crosses the antimeridian (lng = 180 | -180)\n    return crossesPoleOrAntimeridian ? (0,d3_geo__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(polygon, pnt) : (0,_turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(pnt, polygon);\n}\nvar THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n : {\n    BufferGeometry: three__WEBPACK_IMPORTED_MODULE_12__.BufferGeometry,\n    Float32BufferAttribute: three__WEBPACK_IMPORTED_MODULE_12__.Float32BufferAttribute\n};\n// support both modes for backwards threejs compatibility\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? \"setAttribute\" : \"addAttribute\";\nvar ConicPolygonGeometry = /*#__PURE__*/ function(_THREE$BufferGeometry) {\n    function ConicPolygonGeometry(polygonGeoJson, bottomHeight, topHeight, closedBottom, closedTop, includeSides, curvatureResolution) {\n        var _this;\n        _classCallCheck(this, ConicPolygonGeometry);\n        _this = _callSuper(this, ConicPolygonGeometry);\n        _this.type = \"ConicPolygonGeometry\";\n        _this.parameters = {\n            polygonGeoJson: polygonGeoJson,\n            bottomHeight: bottomHeight,\n            topHeight: topHeight,\n            closedBottom: closedBottom,\n            closedTop: closedTop,\n            includeSides: includeSides,\n            curvatureResolution: curvatureResolution\n        };\n        // defaults\n        bottomHeight = bottomHeight || 0;\n        topHeight = topHeight || 1;\n        closedBottom = closedBottom !== undefined ? closedBottom : true;\n        closedTop = closedTop !== undefined ? closedTop : true;\n        includeSides = includeSides !== undefined ? includeSides : true;\n        curvatureResolution = curvatureResolution || 5; // in angular degrees\n        // pre-calculate contour, triangulation and UV maps\n        var _geoPolygonTriangulat = geoPolygonTriangulate(polygonGeoJson, {\n            resolution: curvatureResolution\n        }), contour = _geoPolygonTriangulat.contour, triangles = _geoPolygonTriangulat.triangles;\n        var flatUvs = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(triangles.uvs);\n        var vertices = [];\n        var uvs = [];\n        var indices = [];\n        var groupCnt = 0; // add groups to apply different materials to torso / caps\n        var addGroup = function addGroup(groupData) {\n            var prevVertCnt = Math.round(vertices.length / 3);\n            var prevIndCnt = indices.length;\n            vertices = vertices.concat(groupData.vertices);\n            uvs = uvs.concat(groupData.uvs);\n            indices = indices.concat(!prevVertCnt ? groupData.indices : groupData.indices.map(function(ind) {\n                return ind + prevVertCnt;\n            }));\n            _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n        };\n        includeSides && addGroup(generateTorso());\n        closedBottom && addGroup(generateCap(bottomHeight, false));\n        closedTop && addGroup(generateCap(topHeight, true));\n        // build geometry\n        _this.setIndex(indices);\n        _this[setAttributeFn](\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n        _this[setAttributeFn](\"uv\", new THREE.Float32BufferAttribute(uvs, 2));\n        // auto-calculate normals\n        _this.computeVertexNormals();\n        //\n        function generateVertices(polygon, altitude) {\n            var altFn = typeof altitude === \"function\" ? altitude : function() {\n                return altitude;\n            };\n            var coords3d = polygon.map(function(coords) {\n                return coords.map(function(_ref) {\n                    var _ref2 = _slicedToArray(_ref, 2), lng = _ref2[0], lat = _ref2[1];\n                    return polar2Cartesian(lat, lng, altFn(lng, lat));\n                });\n            });\n            // returns { vertices, holes, coordinates }. Each point generates 3 vertice items (x,y,z).\n            return (0,earcut__WEBPACK_IMPORTED_MODULE_0__.flatten)(coords3d);\n        }\n        function generateTorso() {\n            var _generateVertices = generateVertices(contour, bottomHeight), bottomVerts = _generateVertices.vertices, holes = _generateVertices.holes;\n            var _generateVertices2 = generateVertices(contour, topHeight), topVerts = _generateVertices2.vertices;\n            var vertices = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n                topVerts,\n                bottomVerts\n            ]);\n            var numPoints = Math.round(topVerts.length / 3);\n            var holesIdx = new Set(holes);\n            var lastHoleIdx = 0;\n            var indices = [];\n            for(var v0Idx = 0; v0Idx < numPoints; v0Idx++){\n                var v1Idx = v0Idx + 1; // next point\n                if (v1Idx === numPoints) {\n                    v1Idx = lastHoleIdx; // close final loop\n                } else if (holesIdx.has(v1Idx)) {\n                    var holeIdx = v1Idx;\n                    v1Idx = lastHoleIdx; // close hole loop\n                    lastHoleIdx = holeIdx;\n                }\n                // Each pair of coords generates two triangles (faces)\n                indices.push(v0Idx, v0Idx + numPoints, v1Idx + numPoints);\n                indices.push(v1Idx + numPoints, v1Idx, v0Idx);\n            }\n            var uvs = []; // wrap texture around perimeter (u), with v=1 on top\n            for(var v = 1; v >= 0; v--)for(var i = 0; i < numPoints; i += 1)uvs.push(i / (numPoints - 1), v);\n            return {\n                indices: indices,\n                vertices: vertices,\n                uvs: uvs\n            };\n        }\n        function generateCap(radius) {\n            var isTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            return {\n                // need to reverse-wind the bottom triangles to make them face outwards\n                indices: isTop ? triangles.indices : triangles.indices.slice().reverse(),\n                vertices: generateVertices([\n                    triangles.points\n                ], radius).vertices,\n                uvs: flatUvs\n            };\n        }\n        return _this;\n    }\n    _inherits(ConicPolygonGeometry, _THREE$BufferGeometry);\n    return _createClass(ConicPolygonGeometry);\n}(THREE.BufferGeometry); //\nfunction polar2Cartesian(lat, lng) {\n    var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var phi = (90 - lat) * Math.PI / 180;\n    var theta = (90 - lng) * Math.PI / 180;\n    return [\n        r * Math.sin(phi) * Math.cos(theta),\n        // x\n        r * Math.cos(phi),\n        // y\n        r * Math.sin(phi) * Math.sin(theta) // z\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtY29uaWMtcG9seWdvbi1nZW9tZXRyeS9kaXN0L3RocmVlLWNvbmljLXBvbHlnb24tZ2VvbWV0cnkubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStEO0FBQ2hCO0FBQ047QUFDTDtBQUM0QjtBQUNhO0FBQ2pDO0FBQ0w7QUFFdkMsU0FBU2Usa0JBQWtCQyxDQUFDLEVBQUVDLENBQUM7SUFDNUIsU0FBUUEsS0FBS0EsSUFBSUQsRUFBRUUsTUFBTSxLQUFNRCxDQUFBQSxJQUFJRCxFQUFFRSxNQUFNO0lBQzVDLElBQUssSUFBSUMsSUFBSSxHQUFHQyxJQUFJQyxNQUFNSixJQUFJRSxJQUFJRixHQUFHRSxJQUFLQyxDQUFDLENBQUNELEVBQUUsR0FBR0gsQ0FBQyxDQUFDRyxFQUFFO0lBQ3JELE9BQU9DO0FBQ1Q7QUFDQSxTQUFTRSxnQkFBZ0JOLENBQUM7SUFDeEIsSUFBSUssTUFBTUUsT0FBTyxDQUFDUCxJQUFJLE9BQU9BO0FBQy9CO0FBQ0EsU0FBU1EsbUJBQW1CUixDQUFDO0lBQzNCLElBQUlLLE1BQU1FLE9BQU8sQ0FBQ1AsSUFBSSxPQUFPRCxrQkFBa0JDO0FBQ2pEO0FBQ0EsU0FBU1MsdUJBQXVCTixDQUFDO0lBQy9CLElBQUlPLGNBQWNQLEdBQUcsTUFBTSxJQUFJUSxlQUFlO0lBQzlDLE9BQU9SO0FBQ1Q7QUFDQSxTQUFTUyxXQUFXQyxDQUFDLEVBQUVDLENBQUMsRUFBRVgsQ0FBQztJQUN6QixPQUFPVyxJQUFJQyxnQkFBZ0JELElBQUlFLDJCQUEyQkgsR0FBR0ksOEJBQThCQyxRQUFRQyxTQUFTLENBQUNMLEdBQUcsRUFBRSxFQUFFQyxnQkFBZ0JGLEdBQUdPLFdBQVcsSUFBSU4sRUFBRU8sS0FBSyxDQUFDUixHQUFHVjtBQUNuSztBQUNBLFNBQVNtQixnQkFBZ0JyQixDQUFDLEVBQUVHLENBQUM7SUFDM0IsSUFBSSxDQUFFSCxDQUFBQSxhQUFhRyxDQUFBQSxHQUFJLE1BQU0sSUFB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T2xCLEtBQUt3QixHQUFHLENBQUNnRDtRQUNyQyxJQUFJO1FBQ0pyTixJQUFJNkksS0FBS3dCLEdBQUcsQ0FBQ047UUFDYixJQUFJO1FBQ0ovSixJQUFJNkksS0FBS3lFLEdBQUcsQ0FBQ3ZELE9BQU9sQixLQUFLeUUsR0FBRyxDQUFDRCxPQUFPLElBQUk7S0FDdkM7QUFDSDtBQUUyQyIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvdGhyZWUtY29uaWMtcG9seWdvbi1nZW9tZXRyeS9kaXN0L3RocmVlLWNvbmljLXBvbHlnb24tZ2VvbWV0cnkubWpzPzMwOGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnksIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBtZXJnZSwgZXh0ZW50LCBtZWFuIH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IGVhcmN1dCwgeyBmbGF0dGVuIH0gZnJvbSAnZWFyY3V0JztcbmltcG9ydCBEZWxhdW5hdG9yIGZyb20gJ2RlbGF1bmF0b3InO1xuaW1wb3J0IHR1cmZQb2ludEluUG9seWdvbiBmcm9tICdAdHVyZi9ib29sZWFuLXBvaW50LWluLXBvbHlnb24nO1xuaW1wb3J0IHsgZ2VvQm91bmRzLCBnZW9Db250YWlucywgZ2VvRGlzdGFuY2UsIGdlb0ludGVycG9sYXRlIH0gZnJvbSAnZDMtZ2VvJztcbmltcG9ydCB7IGdlb1Zvcm9ub2kgfSBmcm9tICdkMy1nZW8tdm9yb25vaSc7XG5pbXBvcnQgeyBzY2FsZUxpbmVhciB9IGZyb20gJ2QzLXNjYWxlJztcblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkge1xuICAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7XG4gIGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkocik7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGUpIHtcbiAgaWYgKHVuZGVmaW5lZCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkge1xuICByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7XG4gIGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZih0KSB7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO1xuICB9LCBfZ2V0UHJvdG90eXBlT2YodCk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHModCwgZSkge1xuICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHQsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLCBlICYmIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICB9IGNhdGNoICh0KSB7fVxuICByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdDtcbiAgfSkoKTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkocikge1xuICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gcltTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gcltcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKHIpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9IHRydWUsXG4gICAgICBvID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIDsgZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBvID0gdHJ1ZSwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGUpIHtcbiAgaWYgKGUgJiYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7XG4gIGlmICh1bmRlZmluZWQgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQodCk7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YodCwgZSkge1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgcmV0dXJuIHQuX19wcm90b19fID0gZSwgdDtcbiAgfSwgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xufVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5KHIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7XG4gIGlmIChyKSB7XG4gICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTtcbiAgICB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpO1xuICAgIHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlb1BvbHlnb25Ucmlhbmd1bGF0ZShwb2x5Z29uKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICBfcmVmJHJlc29sdXRpb24gPSBfcmVmLnJlc29sdXRpb24sXG4gICAgcmVzb2x1dGlvbiA9IF9yZWYkcmVzb2x1dGlvbiA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiBfcmVmJHJlc29sdXRpb247XG4gIHZhciBjb250b3VyID0gaW50ZXJwb2xhdGVDb250b3VyUG9pbnRzKHBvbHlnb24sIHJlc29sdXRpb24pO1xuICB2YXIgZWRnZVBvaW50cyA9IG1lcmdlKGNvbnRvdXIpO1xuICB2YXIgaW5uZXJQb2ludHMgPSBnZXRJbm5lckdlb1BvaW50cyhwb2x5Z29uLCByZXNvbHV0aW9uKTtcbiAgdmFyIHBvaW50cyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZWRnZVBvaW50cyksIF90b0NvbnN1bWFibGVBcnJheShpbm5lclBvaW50cykpO1xuICB2YXIgYm91bmRhcmllc0dlb2pzb24gPSB7XG4gICAgdHlwZTogJ1BvbHlnb24nLFxuICAgIGNvb3JkaW5hdGVzOiBwb2x5Z29uXG4gIH07XG4gIHZhciBfZ2VvQm91bmRzID0gZ2VvQm91bmRzKGJvdW5kYXJpZXNHZW9qc29uKSxcbiAgICBfZ2VvQm91bmRzMiA9IF9zbGljZWRUb0FycmF5KF9nZW9Cb3VuZHMsIDIpLFxuICAgIF9nZW9Cb3VuZHMyJCA9IF9zbGljZWRUb0FycmF5KF9nZW9Cb3VuZHMyWzBdLCAyKSxcbiAgICBtaW5MbmcgPSBfZ2VvQm91bmRzMiRbMF0sXG4gICAgbWluTGF0ID0gX2dlb0JvdW5kczIkWzFdLFxuICAgIF9nZW9Cb3VuZHMyJDIgPSBfc2xpY2VkVG9BcnJheShfZ2VvQm91bmRzMlsxXSwgMiksXG4gICAgbWF4TG5nID0gX2dlb0JvdW5kczIkMlswXSxcbiAgICBtYXhMYXQgPSBfZ2VvQm91bmRzMiQyWzFdO1xuICB2YXIgY3Jvc3Nlc1BvbGVPckFudGltZXJpZGlhbiA9IG1pbkxuZyA+IG1heExuZyAvLyBjcm9zc2VzIGFudGltZXJpZGlhblxuICB8fCBtYXhMYXQgPj0gODkgLy8gY3Jvc3NlcyBub3J0aCBwb2xlXG4gIHx8IG1pbkxhdCA8PSAtODk7IC8vIGNyb3NzZXMgc291dGggcG9sZVxuXG4gIHZhciBpbmRpY2VzID0gW107XG4gIGlmIChjcm9zc2VzUG9sZU9yQW50aW1lcmlkaWFuKSB7XG4gICAgLy8gVXNlIGQzLWdlby12b3Jvbm9pLiBTbG93ZXN0LCBidXQgbW9zdCBhY2N1cmF0ZSBmb3IgcG9seWdvbnMgdGhhdCBjcm9zcyBwb2xlcyBvciBhbnRpLW1lcmlkaWFuXG4gICAgdmFyIHZ0ID0gZ2VvVm9yb25vaShwb2ludHMpLnRyaWFuZ2xlcygpOyAvLyBnZW9EZWxhdW5heSBnZW5lcmF0ZXMgbW9yZSB0cmlhbmdsZXMgdGhhbiBuZWVkZWRcbiAgICB2YXIgcG50TWFwID0gbmV3IE1hcChwb2ludHMubWFwKGZ1bmN0aW9uIChfcmVmMiwgaWR4KSB7XG4gICAgICB2YXIgX3JlZjMgPSBfc2xpY2VkVG9BcnJheShfcmVmMiwgMiksXG4gICAgICAgIGxuZyA9IF9yZWYzWzBdLFxuICAgICAgICBsYXQgPSBfcmVmM1sxXTtcbiAgICAgIHJldHVybiBbXCJcIi5jb25jYXQobG5nLCBcIi1cIikuY29uY2F0KGxhdCksIGlkeF07XG4gICAgfSkpO1xuICAgIHZ0LmZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgIHZhciBfaW5kaWNlcztcbiAgICAgIHZhciB0cmlhbmdsZSA9IGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0uc2xpY2UoMCwgMykucmV2ZXJzZSgpOyAvLyByZXZlcnNlIHdvdW5kIHRvIG1hdGNoIGVhcmN1dFxuXG4gICAgICB2YXIgaW5kcyA9IFtdO1xuICAgICAgdHJpYW5nbGUuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICAgICAgdmFyIF9yZWY1ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjQsIDIpLFxuICAgICAgICAgIGxuZyA9IF9yZWY1WzBdLFxuICAgICAgICAgIGxhdCA9IF9yZWY1WzFdO1xuICAgICAgICB2YXIgayA9IFwiXCIuY29uY2F0KGxuZywgXCItXCIpLmNvbmNhdChsYXQpO1xuICAgICAgICBwbnRNYXAuaGFzKGspICYmIGluZHMucHVzaChwbnRNYXAuZ2V0KGspKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGluZHMubGVuZ3RoICE9PSAzKSByZXR1cm47IC8vIHRyaWFuZ2xlIG1hbGZ1bmN0aW9uXG5cbiAgICAgIC8vIGV4Y2x1ZGUgZWRnZSB0cmlhbmdsZXMgb3V0c2lkZSBwb2x5Z29uIHBlcmltZXRlciBvciB0aHJvdWdoIGhvbGVzXG4gICAgICBpZiAoaW5kcy5zb21lKGZ1bmN0aW9uIChpbmQpIHtcbiAgICAgICAgcmV0dXJuIGluZCA8IGVkZ2VQb2ludHMubGVuZ3RoO1xuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIHRyaWFuZ2xlQ2VudHJvaWQgPSBmLnByb3BlcnRpZXMuY2lyY3VtY2VudGVyO1xuICAgICAgICBpZiAoIXBvaW50SW5zaWRlKHRyaWFuZ2xlQ2VudHJvaWQsIGJvdW5kYXJpZXNHZW9qc29uLCBjcm9zc2VzUG9sZU9yQW50aW1lcmlkaWFuKSkgcmV0dXJuO1xuICAgICAgfVxuICAgICAgKF9pbmRpY2VzID0gaW5kaWNlcykucHVzaC5hcHBseShfaW5kaWNlcywgaW5kcyk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoIWlubmVyUG9pbnRzLmxlbmd0aCkge1xuICAgIC8vIGVhcmN1dCB0cmlhbmd1bGF0aW9uIHNsaWdodGx5IG1vcmUgcGVyZm9ybWluZyBpZiBpdCdzIG9ubHkgdXNpbmcgdGhlIHBvbHlnb24gcGVyaW1ldGVyXG4gICAgdmFyIF9lYXJjdXRGbGF0dGVuID0gZmxhdHRlbihjb250b3VyKSxcbiAgICAgIHZlcnRpY2VzID0gX2VhcmN1dEZsYXR0ZW4udmVydGljZXMsXG4gICAgICBfZWFyY3V0RmxhdHRlbiRob2xlcyA9IF9lYXJjdXRGbGF0dGVuLmhvbGVzLFxuICAgICAgaG9sZXMgPSBfZWFyY3V0RmxhdHRlbiRob2xlcyA9PT0gdW5kZWZpbmVkID8gW10gOiBfZWFyY3V0RmxhdHRlbiRob2xlcztcbiAgICBpbmRpY2VzID0gZWFyY3V0KHZlcnRpY2VzLCBob2xlcywgMik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIGRlbGF1bmF0b3JcbiAgICB2YXIgZGVsYXVuYXkgPSBEZWxhdW5hdG9yLmZyb20ocG9pbnRzKTtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICB2YXIgX2luZGljZXMyO1xuICAgICAgdmFyIGluZHMgPSBbMiwgMSwgMF0ubWFwKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgcmV0dXJuIGRlbGF1bmF5LnRyaWFuZ2xlc1tpICsgaWR4XTtcbiAgICAgIH0pOyAvLyByZXZlcnNlIHdvdW5kIHRvIGhhdmUgc2FtZSBvcmllbnRhdGlvbiBhcyBlYXJjdXRcbiAgICAgIHZhciB0cmlhbmdsZSA9IGluZHMubWFwKGZ1bmN0aW9uIChpbmRpY2UpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50c1tpbmRpY2VdO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGV4Y2x1ZGUgZWRnZSB0cmlhbmdsZXMgb3V0c2lkZSBwb2x5Z29uIHBlcmltZXRlciBvciB0aHJvdWdoIGhvbGVzXG4gICAgICBpZiAoaW5kcy5zb21lKGZ1bmN0aW9uIChpbmQpIHtcbiAgICAgICAgcmV0dXJuIGluZCA8IGVkZ2VQb2ludHMubGVuZ3RoO1xuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIHRyaWFuZ2xlQ2VudHJvaWQgPSBbMCwgMV0ubWFwKGZ1bmN0aW9uIChjb29yZElkeCkge1xuICAgICAgICAgIHJldHVybiBtZWFuKHRyaWFuZ2xlLCBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgcmV0dXJuIHBbY29vcmRJZHhdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFwb2ludEluc2lkZSh0cmlhbmdsZUNlbnRyb2lkLCBib3VuZGFyaWVzR2VvanNvbiwgY3Jvc3Nlc1BvbGVPckFudGltZXJpZGlhbikpIHJldHVybiAxOyAvLyBjb250aW51ZVxuICAgICAgfVxuICAgICAgKF9pbmRpY2VzMiA9IGluZGljZXMpLnB1c2guYXBwbHkoX2luZGljZXMyLCBfdG9Db25zdW1hYmxlQXJyYXkoaW5kcykpO1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRlbGF1bmF5LnRyaWFuZ2xlcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgaWYgKF9sb29wKGkpKSBjb250aW51ZTtcbiAgICB9XG4gIH1cblxuICAvLyBjYWxjIHV2c1xuICB2YXIgbG5nVXZTY2FsZSA9IHNjYWxlTGluZWFyKGV4dGVudChwb2ludHMsIGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGRbMF07XG4gIH0pLCBbMCwgMV0pO1xuICB2YXIgbGF0VXZTY2FsZSA9IHNjYWxlTGluZWFyKGV4dGVudChwb2ludHMsIGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGRbMV07XG4gIH0pLCBbMCwgMV0pO1xuICB2YXIgdXZzID0gcG9pbnRzLm1hcChmdW5jdGlvbiAoX3JlZjYpIHtcbiAgICB2YXIgX3JlZjcgPSBfc2xpY2VkVG9BcnJheShfcmVmNiwgMiksXG4gICAgICBsbmcgPSBfcmVmN1swXSxcbiAgICAgIGxhdCA9IF9yZWY3WzFdO1xuICAgIHJldHVybiBbbG5nVXZTY2FsZShsbmcpLCBsYXRVdlNjYWxlKGxhdCldO1xuICB9KTtcbiAgdmFyIHRyaWFuZ2xlcyA9IHtcbiAgICBwb2ludHM6IHBvaW50cyxcbiAgICBpbmRpY2VzOiBpbmRpY2VzLFxuICAgIHV2czogdXZzXG4gIH07XG4gIHJldHVybiB7XG4gICAgY29udG91cjogY29udG91cixcbiAgICB0cmlhbmdsZXM6IHRyaWFuZ2xlc1xuICB9O1xufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVDb250b3VyUG9pbnRzKHBvbHlnb24sIG1heERpc3RhbmNlKSB7XG4gIC8vIGFkZCBpbnRlcnBvbGF0ZWQgcG9pbnRzIGZvciBzZWdtZW50cyB0aGF0IGFyZSBmdXJ0aGVyIGFwYXJ0IHRoYW4gdGhlIG1heCBkaXN0YW5jZVxuICByZXR1cm4gcG9seWdvbi5tYXAoZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgIHZhciBwbnRzID0gW107XG4gICAgdmFyIHByZXZQbnQ7XG4gICAgY29vcmRzLmZvckVhY2goZnVuY3Rpb24gKHBudCkge1xuICAgICAgaWYgKHByZXZQbnQpIHtcbiAgICAgICAgdmFyIGRpc3QgPSBnZW9EaXN0YW5jZShwbnQsIHByZXZQbnQpICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgaWYgKGRpc3QgPiBtYXhEaXN0YW5jZSkge1xuICAgICAgICAgIHZhciBpbnRlcnBvbCA9IGdlb0ludGVycG9sYXRlKHByZXZQbnQsIHBudCk7XG4gICAgICAgICAgdmFyIHRTdGVwID0gMSAvIE1hdGguY2VpbChkaXN0IC8gbWF4RGlzdGFuY2UpO1xuICAgICAgICAgIHZhciB0ID0gdFN0ZXA7XG4gICAgICAgICAgd2hpbGUgKHQgPCAxKSB7XG4gICAgICAgICAgICBwbnRzLnB1c2goaW50ZXJwb2wodCkpO1xuICAgICAgICAgICAgdCArPSB0U3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBudHMucHVzaChwcmV2UG50ID0gcG50KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcG50cztcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRJbm5lckdlb1BvaW50cyhwb2x5Z29uLCBtYXhEaXN0YW5jZSkge1xuICB2YXIgYm91bmRhcmllc0dlb2pzb24gPSB7XG4gICAgdHlwZTogJ1BvbHlnb24nLFxuICAgIGNvb3JkaW5hdGVzOiBwb2x5Z29uXG4gIH07XG4gIHZhciBfZ2VvQm91bmRzMyA9IGdlb0JvdW5kcyhib3VuZGFyaWVzR2VvanNvbiksXG4gICAgX2dlb0JvdW5kczQgPSBfc2xpY2VkVG9BcnJheShfZ2VvQm91bmRzMywgMiksXG4gICAgX2dlb0JvdW5kczQkID0gX3NsaWNlZFRvQXJyYXkoX2dlb0JvdW5kczRbMF0sIDIpLFxuICAgIG1pbkxuZyA9IF9nZW9Cb3VuZHM0JFswXSxcbiAgICBtaW5MYXQgPSBfZ2VvQm91bmRzNCRbMV0sXG4gICAgX2dlb0JvdW5kczQkMiA9IF9zbGljZWRUb0FycmF5KF9nZW9Cb3VuZHM0WzFdLCAyKSxcbiAgICBtYXhMbmcgPSBfZ2VvQm91bmRzNCQyWzBdLFxuICAgIG1heExhdCA9IF9nZW9Cb3VuZHM0JDJbMV07XG5cbiAgLy8gcG9seWdvbiBzbWFsbGVyIHRoYW4gbWF4RGlzdGFuY2UgLT4gbm8gaW5uZXIgcG9pbnRzXG4gIGlmIChNYXRoLm1pbihNYXRoLmFicyhtYXhMbmcgLSBtaW5MbmcpLCBNYXRoLmFicyhtYXhMYXQgLSBtaW5MYXQpKSA8IG1heERpc3RhbmNlKSByZXR1cm4gW107XG4gIHZhciBjcm9zc2VzUG9sZU9yQW50aW1lcmlkaWFuID0gbWluTG5nID4gbWF4TG5nIHx8IG1heExhdCA+PSA4OSB8fCBtaW5MYXQgPD0gLTg5O1xuICByZXR1cm4gZ2V0R2VvU3BpcmFsR3JpZChtYXhEaXN0YW5jZSwge1xuICAgIG1pbkxuZzogbWluTG5nLFxuICAgIG1heExuZzogbWF4TG5nLFxuICAgIG1pbkxhdDogbWluTGF0LFxuICAgIG1heExhdDogbWF4TGF0XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAocG50KSB7XG4gICAgcmV0dXJuIHBvaW50SW5zaWRlKHBudCwgYm91bmRhcmllc0dlb2pzb24sIGNyb3NzZXNQb2xlT3JBbnRpbWVyaWRpYW4pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEdlb1NwaXJhbEdyaWQoZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKSB7XG4gIHZhciBfcmVmOCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgbWluTG5nID0gX3JlZjgubWluTG5nLFxuICAgIG1heExuZyA9IF9yZWY4Lm1heExuZyxcbiAgICBtaW5MYXQgPSBfcmVmOC5taW5MYXQsXG4gICAgbWF4TGF0ID0gX3JlZjgubWF4TGF0O1xuICB2YXIgbnVtUG9pbnRzID0gTWF0aC5yb3VuZChNYXRoLnBvdygzNjAgLyBkaXN0YW5jZUJldHdlZW5Qb2ludHMsIDIpIC8gTWF0aC5QSSk7XG5cbiAgLy8gaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BtYm9zdG9jay9zcGhlcmljYWwtZmlib25hY2NpLWxhdHRpY2VcbiAgdmFyIHBoaSA9ICgxICsgTWF0aC5zcXJ0KDUpKSAvIDI7IC8vIGdvbGRlbiByYXRpb1xuXG4gIHZhciBnZXRQbnRMbmcgPSBmdW5jdGlvbiBnZXRQbnRMbmcoaWR4KSB7XG4gICAgcmV0dXJuIGlkeCAvIHBoaSAqIDM2MCAlIDM2MCAtIDE4MDtcbiAgfTtcbiAgdmFyIGdldFBudExhdCA9IGZ1bmN0aW9uIGdldFBudExhdChpZHgpIHtcbiAgICByZXR1cm4gTWF0aC5hY29zKDIgKiBpZHggLyBudW1Qb2ludHMgLSAxKSAvIE1hdGguUEkgKiAxODAgLSA5MDtcbiAgfTtcbiAgdmFyIGdldFBudElkeCA9IGZ1bmN0aW9uIGdldFBudElkeChsYXQpIHtcbiAgICByZXR1cm4gbnVtUG9pbnRzICogKE1hdGguY29zKChsYXQgKyA5MCkgKiBNYXRoLlBJIC8gMTgwKSArIDEpIC8gMjtcbiAgfTtcbiAgdmFyIHBudElkeFJhbmdlID0gW21heExhdCAhPT0gdW5kZWZpbmVkID8gTWF0aC5jZWlsKGdldFBudElkeChtYXhMYXQpKSA6IDAsIG1pbkxhdCAhPT0gdW5kZWZpbmVkID8gTWF0aC5mbG9vcihnZXRQbnRJZHgobWluTGF0KSkgOiBudW1Qb2ludHMgLSAxXTtcbiAgdmFyIGlzTG5nSW5SYW5nZSA9IG1pbkxuZyA9PT0gdW5kZWZpbmVkICYmIG1heExuZyA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IDogbWluTG5nID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAobG5nKSB7XG4gICAgcmV0dXJuIGxuZyA8PSBtYXhMbmc7XG4gIH0gOiBtYXhMbmcgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChsbmcpIHtcbiAgICByZXR1cm4gbG5nID49IG1pbkxuZztcbiAgfSA6IG1heExuZyA+PSBtaW5MbmcgPyBmdW5jdGlvbiAobG5nKSB7XG4gICAgcmV0dXJuIGxuZyA+PSBtaW5MbmcgJiYgbG5nIDw9IG1heExuZztcbiAgfSA6IGZ1bmN0aW9uIChsbmcpIHtcbiAgICByZXR1cm4gbG5nID49IG1pbkxuZyB8fCBsbmcgPD0gbWF4TG5nO1xuICB9OyAvLyBmb3IgcmFuZ2VzIHRoYXQgY3Jvc3MgdGhlIGFudGktbWVyaWRpYW5cblxuICB2YXIgcG50cyA9IFtdO1xuICBmb3IgKHZhciBpID0gcG50SWR4UmFuZ2VbMF07IGkgPD0gcG50SWR4UmFuZ2VbMV07IGkrKykge1xuICAgIHZhciBsbmcgPSBnZXRQbnRMbmcoaSk7XG4gICAgaXNMbmdJblJhbmdlKGxuZykgJiYgcG50cy5wdXNoKFtsbmcsIGdldFBudExhdChpKV0pO1xuICB9XG4gIHJldHVybiBwbnRzO1xufVxuZnVuY3Rpb24gcG9pbnRJbnNpZGUocG50LCBwb2x5Z29uKSB7XG4gIHZhciBjcm9zc2VzUG9sZU9yQW50aW1lcmlkaWFuID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgLy8gdHVyZiBtZXRob2QgaXMgbW9yZSBwZXJmb3JtaW5nIGJ1dCBtYWxmdW5jdGlvbnMgaWYgcG9seWdvbiBpbmNsdWRlcyBhIHBvbGUgKGxhdCA9IDkwIHwgLTkwKSBvciBjcm9zc2VzIHRoZSBhbnRpbWVyaWRpYW4gKGxuZyA9IDE4MCB8IC0xODApXG4gIHJldHVybiBjcm9zc2VzUG9sZU9yQW50aW1lcmlkaWFuID8gZ2VvQ29udGFpbnMocG9seWdvbiwgcG50KSA6IHR1cmZQb2ludEluUG9seWdvbihwbnQsIHBvbHlnb24pO1xufVxuXG52YXIgVEhSRUUgPSB3aW5kb3cuVEhSRUUgPyB3aW5kb3cuVEhSRUUgLy8gUHJlZmVyIGNvbnN1bXB0aW9uIGZyb20gZ2xvYmFsIFRIUkVFLCBpZiBleGlzdHNcbjoge1xuICBCdWZmZXJHZW9tZXRyeTogQnVmZmVyR2VvbWV0cnksXG4gIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGU6IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGVcbn07XG5cbi8vIHN1cHBvcnQgYm90aCBtb2RlcyBmb3IgYmFja3dhcmRzIHRocmVlanMgY29tcGF0aWJpbGl0eVxudmFyIHNldEF0dHJpYnV0ZUZuID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0QXR0cmlidXRlID8gJ3NldEF0dHJpYnV0ZScgOiAnYWRkQXR0cmlidXRlJztcbnZhciBDb25pY1BvbHlnb25HZW9tZXRyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RIUkVFJEJ1ZmZlckdlb21ldHJ5KSB7XG4gIGZ1bmN0aW9uIENvbmljUG9seWdvbkdlb21ldHJ5KHBvbHlnb25HZW9Kc29uLCBib3R0b21IZWlnaHQsIHRvcEhlaWdodCwgY2xvc2VkQm90dG9tLCBjbG9zZWRUb3AsIGluY2x1ZGVTaWRlcywgY3VydmF0dXJlUmVzb2x1dGlvbikge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uaWNQb2x5Z29uR2VvbWV0cnkpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBDb25pY1BvbHlnb25HZW9tZXRyeSk7XG4gICAgX3RoaXMudHlwZSA9ICdDb25pY1BvbHlnb25HZW9tZXRyeSc7XG4gICAgX3RoaXMucGFyYW1ldGVycyA9IHtcbiAgICAgIHBvbHlnb25HZW9Kc29uOiBwb2x5Z29uR2VvSnNvbixcbiAgICAgIGJvdHRvbUhlaWdodDogYm90dG9tSGVpZ2h0LFxuICAgICAgdG9wSGVpZ2h0OiB0b3BIZWlnaHQsXG4gICAgICBjbG9zZWRCb3R0b206IGNsb3NlZEJvdHRvbSxcbiAgICAgIGNsb3NlZFRvcDogY2xvc2VkVG9wLFxuICAgICAgaW5jbHVkZVNpZGVzOiBpbmNsdWRlU2lkZXMsXG4gICAgICBjdXJ2YXR1cmVSZXNvbHV0aW9uOiBjdXJ2YXR1cmVSZXNvbHV0aW9uXG4gICAgfTtcblxuICAgIC8vIGRlZmF1bHRzXG4gICAgYm90dG9tSGVpZ2h0ID0gYm90dG9tSGVpZ2h0IHx8IDA7XG4gICAgdG9wSGVpZ2h0ID0gdG9wSGVpZ2h0IHx8IDE7XG4gICAgY2xvc2VkQm90dG9tID0gY2xvc2VkQm90dG9tICE9PSB1bmRlZmluZWQgPyBjbG9zZWRCb3R0b20gOiB0cnVlO1xuICAgIGNsb3NlZFRvcCA9IGNsb3NlZFRvcCAhPT0gdW5kZWZpbmVkID8gY2xvc2VkVG9wIDogdHJ1ZTtcbiAgICBpbmNsdWRlU2lkZXMgPSBpbmNsdWRlU2lkZXMgIT09IHVuZGVmaW5lZCA/IGluY2x1ZGVTaWRlcyA6IHRydWU7XG4gICAgY3VydmF0dXJlUmVzb2x1dGlvbiA9IGN1cnZhdHVyZVJlc29sdXRpb24gfHwgNTsgLy8gaW4gYW5ndWxhciBkZWdyZWVzXG5cbiAgICAvLyBwcmUtY2FsY3VsYXRlIGNvbnRvdXIsIHRyaWFuZ3VsYXRpb24gYW5kIFVWIG1hcHNcbiAgICB2YXIgX2dlb1BvbHlnb25Ucmlhbmd1bGF0ID0gZ2VvUG9seWdvblRyaWFuZ3VsYXRlKHBvbHlnb25HZW9Kc29uLCB7XG4gICAgICAgIHJlc29sdXRpb246IGN1cnZhdHVyZVJlc29sdXRpb25cbiAgICAgIH0pLFxuICAgICAgY29udG91ciA9IF9nZW9Qb2x5Z29uVHJpYW5ndWxhdC5jb250b3VyLFxuICAgICAgdHJpYW5nbGVzID0gX2dlb1BvbHlnb25Ucmlhbmd1bGF0LnRyaWFuZ2xlcztcbiAgICB2YXIgZmxhdFV2cyA9IG1lcmdlKHRyaWFuZ2xlcy51dnMpO1xuICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgIHZhciB1dnMgPSBbXTtcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIHZhciBncm91cENudCA9IDA7IC8vIGFkZCBncm91cHMgdG8gYXBwbHkgZGlmZmVyZW50IG1hdGVyaWFscyB0byB0b3JzbyAvIGNhcHNcblxuICAgIHZhciBhZGRHcm91cCA9IGZ1bmN0aW9uIGFkZEdyb3VwKGdyb3VwRGF0YSkge1xuICAgICAgdmFyIHByZXZWZXJ0Q250ID0gTWF0aC5yb3VuZCh2ZXJ0aWNlcy5sZW5ndGggLyAzKTtcbiAgICAgIHZhciBwcmV2SW5kQ250ID0gaW5kaWNlcy5sZW5ndGg7XG4gICAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdChncm91cERhdGEudmVydGljZXMpO1xuICAgICAgdXZzID0gdXZzLmNvbmNhdChncm91cERhdGEudXZzKTtcbiAgICAgIGluZGljZXMgPSBpbmRpY2VzLmNvbmNhdCghcHJldlZlcnRDbnQgPyBncm91cERhdGEuaW5kaWNlcyA6IGdyb3VwRGF0YS5pbmRpY2VzLm1hcChmdW5jdGlvbiAoaW5kKSB7XG4gICAgICAgIHJldHVybiBpbmQgKyBwcmV2VmVydENudDtcbiAgICAgIH0pKTtcbiAgICAgIF90aGlzLmFkZEdyb3VwKHByZXZJbmRDbnQsIGluZGljZXMubGVuZ3RoIC0gcHJldkluZENudCwgZ3JvdXBDbnQrKyk7XG4gICAgfTtcbiAgICBpbmNsdWRlU2lkZXMgJiYgYWRkR3JvdXAoZ2VuZXJhdGVUb3JzbygpKTtcbiAgICBjbG9zZWRCb3R0b20gJiYgYWRkR3JvdXAoZ2VuZXJhdGVDYXAoYm90dG9tSGVpZ2h0LCBmYWxzZSkpO1xuICAgIGNsb3NlZFRvcCAmJiBhZGRHcm91cChnZW5lcmF0ZUNhcCh0b3BIZWlnaHQsIHRydWUpKTtcblxuICAgIC8vIGJ1aWxkIGdlb21ldHJ5XG4gICAgX3RoaXMuc2V0SW5kZXgoaW5kaWNlcyk7XG4gICAgX3RoaXNbc2V0QXR0cmlidXRlRm5dKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG4gICAgX3RoaXNbc2V0QXR0cmlidXRlRm5dKCd1dicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2cywgMikpO1xuXG4gICAgLy8gYXV0by1jYWxjdWxhdGUgbm9ybWFsc1xuICAgIF90aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbiAgICAvL1xuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVWZXJ0aWNlcyhwb2x5Z29uLCBhbHRpdHVkZSkge1xuICAgICAgdmFyIGFsdEZuID0gdHlwZW9mIGFsdGl0dWRlID09PSAnZnVuY3Rpb24nID8gYWx0aXR1ZGUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhbHRpdHVkZTtcbiAgICAgIH07XG4gICAgICB2YXIgY29vcmRzM2QgPSBwb2x5Z29uLm1hcChmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgICAgIHJldHVybiBjb29yZHMubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgICBsbmcgPSBfcmVmMlswXSxcbiAgICAgICAgICAgIGxhdCA9IF9yZWYyWzFdO1xuICAgICAgICAgIHJldHVybiBwb2xhcjJDYXJ0ZXNpYW4obGF0LCBsbmcsIGFsdEZuKGxuZywgbGF0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAvLyByZXR1cm5zIHsgdmVydGljZXMsIGhvbGVzLCBjb29yZGluYXRlcyB9LiBFYWNoIHBvaW50IGdlbmVyYXRlcyAzIHZlcnRpY2UgaXRlbXMgKHgseSx6KS5cbiAgICAgIHJldHVybiBmbGF0dGVuKGNvb3JkczNkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVUb3JzbygpIHtcbiAgICAgIHZhciBfZ2VuZXJhdGVWZXJ0aWNlcyA9IGdlbmVyYXRlVmVydGljZXMoY29udG91ciwgYm90dG9tSGVpZ2h0KSxcbiAgICAgICAgYm90dG9tVmVydHMgPSBfZ2VuZXJhdGVWZXJ0aWNlcy52ZXJ0aWNlcyxcbiAgICAgICAgaG9sZXMgPSBfZ2VuZXJhdGVWZXJ0aWNlcy5ob2xlcztcbiAgICAgIHZhciBfZ2VuZXJhdGVWZXJ0aWNlczIgPSBnZW5lcmF0ZVZlcnRpY2VzKGNvbnRvdXIsIHRvcEhlaWdodCksXG4gICAgICAgIHRvcFZlcnRzID0gX2dlbmVyYXRlVmVydGljZXMyLnZlcnRpY2VzO1xuICAgICAgdmFyIHZlcnRpY2VzID0gbWVyZ2UoW3RvcFZlcnRzLCBib3R0b21WZXJ0c10pO1xuICAgICAgdmFyIG51bVBvaW50cyA9IE1hdGgucm91bmQodG9wVmVydHMubGVuZ3RoIC8gMyk7XG4gICAgICB2YXIgaG9sZXNJZHggPSBuZXcgU2V0KGhvbGVzKTtcbiAgICAgIHZhciBsYXN0SG9sZUlkeCA9IDA7XG4gICAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgdjBJZHggPSAwOyB2MElkeCA8IG51bVBvaW50czsgdjBJZHgrKykge1xuICAgICAgICB2YXIgdjFJZHggPSB2MElkeCArIDE7IC8vIG5leHQgcG9pbnRcbiAgICAgICAgaWYgKHYxSWR4ID09PSBudW1Qb2ludHMpIHtcbiAgICAgICAgICB2MUlkeCA9IGxhc3RIb2xlSWR4OyAvLyBjbG9zZSBmaW5hbCBsb29wXG4gICAgICAgIH0gZWxzZSBpZiAoaG9sZXNJZHguaGFzKHYxSWR4KSkge1xuICAgICAgICAgIHZhciBob2xlSWR4ID0gdjFJZHg7XG4gICAgICAgICAgdjFJZHggPSBsYXN0SG9sZUlkeDsgLy8gY2xvc2UgaG9sZSBsb29wXG4gICAgICAgICAgbGFzdEhvbGVJZHggPSBob2xlSWR4O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRWFjaCBwYWlyIG9mIGNvb3JkcyBnZW5lcmF0ZXMgdHdvIHRyaWFuZ2xlcyAoZmFjZXMpXG4gICAgICAgIGluZGljZXMucHVzaCh2MElkeCwgdjBJZHggKyBudW1Qb2ludHMsIHYxSWR4ICsgbnVtUG9pbnRzKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKHYxSWR4ICsgbnVtUG9pbnRzLCB2MUlkeCwgdjBJZHgpO1xuICAgICAgfVxuICAgICAgdmFyIHV2cyA9IFtdOyAvLyB3cmFwIHRleHR1cmUgYXJvdW5kIHBlcmltZXRlciAodSksIHdpdGggdj0xIG9uIHRvcFxuICAgICAgZm9yICh2YXIgdiA9IDE7IHYgPj0gMDsgdi0tKSBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBvaW50czsgaSArPSAxKSB1dnMucHVzaChpIC8gKG51bVBvaW50cyAtIDEpLCB2KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGljZXM6IGluZGljZXMsXG4gICAgICAgIHZlcnRpY2VzOiB2ZXJ0aWNlcyxcbiAgICAgICAgdXZzOiB1dnNcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQ2FwKHJhZGl1cykge1xuICAgICAgdmFyIGlzVG9wID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gbmVlZCB0byByZXZlcnNlLXdpbmQgdGhlIGJvdHRvbSB0cmlhbmdsZXMgdG8gbWFrZSB0aGVtIGZhY2Ugb3V0d2FyZHNcbiAgICAgICAgaW5kaWNlczogaXNUb3AgPyB0cmlhbmdsZXMuaW5kaWNlcyA6IHRyaWFuZ2xlcy5pbmRpY2VzLnNsaWNlKCkucmV2ZXJzZSgpLFxuICAgICAgICB2ZXJ0aWNlczogZ2VuZXJhdGVWZXJ0aWNlcyhbdHJpYW5nbGVzLnBvaW50c10sIHJhZGl1cykudmVydGljZXMsXG4gICAgICAgIHV2czogZmxhdFV2c1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhDb25pY1BvbHlnb25HZW9tZXRyeSwgX1RIUkVFJEJ1ZmZlckdlb21ldHJ5KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDb25pY1BvbHlnb25HZW9tZXRyeSk7XG59KFRIUkVFLkJ1ZmZlckdlb21ldHJ5KTsgLy9cbmZ1bmN0aW9uIHBvbGFyMkNhcnRlc2lhbihsYXQsIGxuZykge1xuICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgdmFyIHBoaSA9ICg5MCAtIGxhdCkgKiBNYXRoLlBJIC8gMTgwO1xuICB2YXIgdGhldGEgPSAoOTAgLSBsbmcpICogTWF0aC5QSSAvIDE4MDtcbiAgcmV0dXJuIFtyICogTWF0aC5zaW4ocGhpKSAqIE1hdGguY29zKHRoZXRhKSxcbiAgLy8geFxuICByICogTWF0aC5jb3MocGhpKSxcbiAgLy8geVxuICByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguc2luKHRoZXRhKSAvLyB6XG4gIF07XG59XG5cbmV4cG9ydCB7IENvbmljUG9seWdvbkdlb21ldHJ5IGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJCdWZmZXJHZW9tZXRyeSIsIkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUiLCJtZXJnZSIsImV4dGVudCIsIm1lYW4iLCJlYXJjdXQiLCJmbGF0dGVuIiwiRGVsYXVuYXRvciIsInR1cmZQb2ludEluUG9seWdvbiIsImdlb0JvdW5kcyIsImdlb0NvbnRhaW5zIiwiZ2VvRGlzdGFuY2UiLCJnZW9JbnRlcnBvbGF0ZSIsImdlb1Zvcm9ub2kiLCJzY2FsZUxpbmVhciIsIl9hcnJheUxpa2VUb0FycmF5IiwiciIsImEiLCJsZW5ndGgiLCJlIiwibiIsIkFycmF5IiwiX2FycmF5V2l0aEhvbGVzIiwiaXNBcnJheSIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJ1bmRlZmluZWQiLCJSZWZlcmVuY2VFcnJvciIsIl9jYWxsU3VwZXIiLCJ0IiwibyIsIl9nZXRQcm90b3R5cGVPZiIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIlJlZmxlY3QiLCJjb25zdHJ1Y3QiLCJjb25zdHJ1Y3RvciIsImFwcGx5IiwiX2NsYXNzQ2FsbENoZWNrIiwiVHlwZUVycm9yIiwiX2NyZWF0ZUNsYXNzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0YWJsZSIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJiaW5kIiwiX19wcm90b19fIiwiX2luaGVyaXRzIiwicHJvdG90eXBlIiwiY3JlYXRlIiwidmFsdWUiLCJjb25maWd1cmFibGUiLCJfc2V0UHJvdG90eXBlT2YiLCJCb29sZWFuIiwidmFsdWVPZiIsImNhbGwiLCJfaXRlcmFibGVUb0FycmF5IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJmcm9tIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwibCIsImkiLCJ1IiwiZiIsIm5leHQiLCJkb25lIiwicHVzaCIsInJldHVybiIsIl9ub25JdGVyYWJsZVJlc3QiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJfc2xpY2VkVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl90b0NvbnN1bWFibGVBcnJheSIsInRvU3RyaW5nIiwic2xpY2UiLCJuYW1lIiwidGVzdCIsImdlb1BvbHlnb25Ucmlhbmd1bGF0ZSIsInBvbHlnb24iLCJfcmVmIiwiYXJndW1lbnRzIiwiX3JlZiRyZXNvbHV0aW9uIiwicmVzb2x1dGlvbiIsIkluZmluaXR5IiwiY29udG91ciIsImludGVycG9sYXRlQ29udG91clBvaW50cyIsImVkZ2VQb2ludHMiLCJpbm5lclBvaW50cyIsImdldElubmVyR2VvUG9pbnRzIiwicG9pbnRzIiwiY29uY2F0IiwiYm91bmRhcmllc0dlb2pzb24iLCJ0eXBlIiwiY29vcmRpbmF0ZXMiLCJfZ2VvQm91bmRzIiwiX2dlb0JvdW5kczIiLCJfZ2VvQm91bmRzMiQiLCJtaW5MbmciLCJtaW5MYXQiLCJfZ2VvQm91bmRzMiQyIiwibWF4TG5nIiwibWF4TGF0IiwiY3Jvc3Nlc1BvbGVPckFudGltZXJpZGlhbiIsImluZGljZXMiLCJ2dCIsInRyaWFuZ2xlcyIsInBudE1hcCIsIk1hcCIsIm1hcCIsIl9yZWYyIiwiaWR4IiwiX3JlZjMiLCJsbmciLCJsYXQiLCJmZWF0dXJlcyIsImZvckVhY2giLCJfaW5kaWNlcyIsInRyaWFuZ2xlIiwiZ2VvbWV0cnkiLCJyZXZlcnNlIiwiaW5kcyIsIl9yZWY0IiwiX3JlZjUiLCJrIiwiaGFzIiwiZ2V0Iiwic29tZSIsImluZCIsInRyaWFuZ2xlQ2VudHJvaWQiLCJwcm9wZXJ0aWVzIiwiY2lyY3VtY2VudGVyIiwicG9pbnRJbnNpZGUiLCJfZWFyY3V0RmxhdHRlbiIsInZlcnRpY2VzIiwiX2VhcmN1dEZsYXR0ZW4kaG9sZXMiLCJob2xlcyIsImRlbGF1bmF5IiwiX2xvb3AiLCJfaW5kaWNlczIiLCJpbmRpY2UiLCJjb29yZElkeCIsInAiLCJsZW4iLCJsbmdVdlNjYWxlIiwiZCIsImxhdFV2U2NhbGUiLCJ1dnMiLCJfcmVmNiIsIl9yZWY3IiwibWF4RGlzdGFuY2UiLCJjb29yZHMiLCJwbnRzIiwicHJldlBudCIsInBudCIsImRpc3QiLCJNYXRoIiwiUEkiLCJpbnRlcnBvbCIsInRTdGVwIiwiY2VpbCIsIl9nZW9Cb3VuZHMzIiwiX2dlb0JvdW5kczQiLCJfZ2VvQm91bmRzNCQiLCJfZ2VvQm91bmRzNCQyIiwibWluIiwiYWJzIiwiZ2V0R2VvU3BpcmFsR3JpZCIsImZpbHRlciIsImRpc3RhbmNlQmV0d2VlblBvaW50cyIsIl9yZWY4IiwibnVtUG9pbnRzIiwicm91bmQiLCJwb3ciLCJwaGkiLCJzcXJ0IiwiZ2V0UG50TG5nIiwiZ2V0UG50TGF0IiwiYWNvcyIsImdldFBudElkeCIsImNvcyIsInBudElkeFJhbmdlIiwiZmxvb3IiLCJpc0xuZ0luUmFuZ2UiLCJUSFJFRSIsIndpbmRvdyIsInNldEF0dHJpYnV0ZUZuIiwic2V0QXR0cmlidXRlIiwiQ29uaWNQb2x5Z29uR2VvbWV0cnkiLCJfVEhSRUUkQnVmZmVyR2VvbWV0cnkiLCJwb2x5Z29uR2VvSnNvbiIsImJvdHRvbUhlaWdodCIsInRvcEhlaWdodCIsImNsb3NlZEJvdHRvbSIsImNsb3NlZFRvcCIsImluY2x1ZGVTaWRlcyIsImN1cnZhdHVyZVJlc29sdXRpb24iLCJfdGhpcyIsInBhcmFtZXRlcnMiLCJfZ2VvUG9seWdvblRyaWFuZ3VsYXQiLCJmbGF0VXZzIiwiZ3JvdXBDbnQiLCJhZGRHcm91cCIsImdyb3VwRGF0YSIsInByZXZWZXJ0Q250IiwicHJldkluZENudCIsImdlbmVyYXRlVG9yc28iLCJnZW5lcmF0ZUNhcCIsInNldEluZGV4IiwiY29tcHV0ZVZlcnRleE5vcm1hbHMiLCJnZW5lcmF0ZVZlcnRpY2VzIiwiYWx0aXR1ZGUiLCJhbHRGbiIsImNvb3JkczNkIiwicG9sYXIyQ2FydGVzaWFuIiwiX2dlbmVyYXRlVmVydGljZXMiLCJib3R0b21WZXJ0cyIsIl9nZW5lcmF0ZVZlcnRpY2VzMiIsInRvcFZlcnRzIiwiaG9sZXNJZHgiLCJTZXQiLCJsYXN0SG9sZUlkeCIsInYwSWR4IiwidjFJZHgiLCJob2xlSWR4IiwidiIsInJhZGl1cyIsImlzVG9wIiwidGhldGEiLCJzaW4iLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-conic-polygon-geometry/dist/three-conic-polygon-geometry.mjs\n");

/***/ })

};
;